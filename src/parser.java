
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Mon Aug 25 22:59:10 GMT-03:00 2014
//----------------------------------------------------

import java_cup.runtime.*;
import java.util.*;
import symbTable.*;
import tipo.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Mon Aug 25 22:59:10 GMT-03:00 2014
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\u010e\000\002\002\006\000\002\002\004\000\002\003" +
    "\004\000\002\210\002\000\002\003\010\000\002\004\005" +
    "\000\002\004\003\000\002\211\002\000\002\007\011\000" +
    "\002\010\006\000\002\011\005\000\002\212\002\000\002" +
    "\011\005\000\002\011\002\000\002\012\005\000\002\012" +
    "\003\000\002\013\003\000\002\014\004\000\002\014\002" +
    "\000\002\015\004\000\002\015\003\000\002\016\006\000" +
    "\002\213\002\000\002\016\005\000\002\017\003\000\002" +
    "\017\005\000\002\020\003\000\002\020\005\000\002\021" +
    "\003\000\002\021\005\000\002\022\004\000\002\022\003" +
    "\000\002\023\003\000\002\023\005\000\002\024\003\000" +
    "\002\024\005\000\002\024\003\000\002\024\004\000\002" +
    "\025\003\000\002\025\004\000\002\025\003\000\002\205" +
    "\003\000\002\205\003\000\002\026\003\000\002\026\003" +
    "\000\002\026\003\000\002\027\004\000\002\027\002\000" +
    "\002\030\004\000\002\030\003\000\002\031\006\000\002" +
    "\214\002\000\002\031\005\000\002\032\003\000\002\032" +
    "\003\000\002\032\003\000\002\032\003\000\002\032\003" +
    "\000\002\032\003\000\002\032\003\000\002\034\003\000" +
    "\002\034\003\000\002\034\003\000\002\035\003\000\002" +
    "\035\003\000\002\036\005\000\002\037\005\000\002\040" +
    "\003\000\002\040\004\000\002\041\003\000\002\041\003" +
    "\000\002\041\003\000\002\041\003\000\002\042\010\000" +
    "\002\043\005\000\002\043\003\000\002\044\003\000\002" +
    "\045\003\000\002\045\003\000\002\046\003\000\002\047" +
    "\005\000\002\047\007\000\002\047\005\000\002\050\005" +
    "\000\002\050\003\000\002\051\005\000\002\052\007\000" +
    "\002\052\006\000\002\052\002\000\002\053\005\000\002" +
    "\053\003\000\002\054\005\000\002\054\003\000\002\055" +
    "\007\000\002\055\011\000\002\055\007\000\002\056\005" +
    "\000\002\056\003\000\002\057\003\000\002\057\005\000" +
    "\002\060\003\000\002\061\003\000\002\062\005\000\002" +
    "\063\003\000\002\064\005\000\002\065\004\000\002\066" +
    "\003\000\002\067\004\000\002\067\002\000\002\070\004" +
    "\000\002\070\003\000\002\071\006\000\002\215\002\000" +
    "\002\071\005\000\002\072\004\000\002\072\002\000\002" +
    "\073\005\000\002\073\003\000\002\074\003\000\002\074" +
    "\003\000\002\075\005\000\002\075\005\000\002\076\003" +
    "\000\002\216\002\000\002\076\005\000\002\077\003\000" +
    "\002\077\003\000\002\100\005\000\002\101\005\000\002" +
    "\101\003\000\002\102\003\000\002\102\003\000\002\102" +
    "\003\000\002\102\003\000\002\103\005\000\002\104\006" +
    "\000\002\105\003\000\002\106\003\000\002\107\004\000" +
    "\002\112\003\000\002\113\005\000\002\113\005\000\002" +
    "\113\005\000\002\114\006\000\002\217\002\000\002\114" +
    "\007\000\002\033\003\000\002\110\004\000\002\115\003" +
    "\000\002\116\003\000\002\117\005\000\002\120\005\000" +
    "\002\120\003\000\002\121\003\000\002\121\003\000\002" +
    "\122\005\000\002\122\003\000\002\123\005\000\002\123" +
    "\003\000\002\124\003\000\002\124\003\000\002\124\003" +
    "\000\002\124\003\000\002\124\003\000\002\124\003\000" +
    "\002\124\003\000\002\124\003\000\002\124\003\000\002" +
    "\124\003\000\002\124\002\000\002\125\003\000\002\125" +
    "\003\000\002\125\003\000\002\125\003\000\002\220\002" +
    "\000\002\126\007\000\002\006\004\000\002\127\005\000" +
    "\002\130\005\000\002\005\010\000\002\131\005\000\002" +
    "\132\005\000\002\133\006\000\002\134\006\000\002\135" +
    "\006\000\002\135\010\000\002\136\010\000\002\137\005" +
    "\000\002\140\003\000\002\140\003\000\002\140\003\000" +
    "\002\140\004\000\002\141\006\000\002\142\005\000\002" +
    "\142\003\000\002\143\003\000\002\144\005\000\002\145" +
    "\004\000\002\145\003\000\002\146\005\000\002\147\005" +
    "\000\002\147\003\000\002\150\003\000\002\150\005\000" +
    "\002\150\007\000\002\151\004\000\002\152\007\000\002" +
    "\152\010\000\002\153\003\000\002\154\005\000\002\154" +
    "\003\000\002\155\005\000\002\156\003\000\002\157\003" +
    "\000\002\111\003\000\002\111\003\000\002\160\003\000" +
    "\002\161\005\000\002\161\003\000\002\162\003\000\002" +
    "\163\003\000\002\163\005\000\002\164\003\000\002\164" +
    "\005\000\002\165\003\000\002\165\005\000\002\166\004" +
    "\000\002\166\003\000\002\167\003\000\002\167\005\000" +
    "\002\170\003\000\002\170\003\000\002\170\003\000\002" +
    "\170\003\000\002\170\005\000\002\170\004\000\002\170" +
    "\003\000\002\170\003\000\002\171\003\000\002\171\003" +
    "\000\002\171\003\000\002\172\003\000\002\172\003\000" +
    "\002\173\003\000\002\174\003\000\002\175\004\000\002" +
    "\176\005\000\002\176\004\000\002\177\005\000\002\177" +
    "\003\000\002\200\005\000\002\200\003\000\002\203\003" +
    "\000\002\203\003\000\002\203\003\000\002\204\003\000" +
    "\002\204\003\000\002\204\003\000\002\204\003\000\002" +
    "\204\003\000\002\201\003\000\002\201\003\000\002\201" +
    "\003\000\002\201\003\000\002\201\003\000\002\201\003" +
    "\000\002\201\003\000\002\202\003\000\002\206\003\000" +
    "\002\207\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\u01a6\000\004\043\006\001\002\000\004\002\u01a8\001" +
    "\002\000\004\063\021\001\002\000\004\065\010\001\002" +
    "\000\006\063\uffff\101\ufffe\001\002\000\110\010\ufef6\012" +
    "\ufef6\013\ufef6\014\ufef6\015\ufef6\016\ufef6\017\ufef6\020\ufef6" +
    "\021\ufef6\022\ufef6\023\ufef6\024\ufef6\034\ufef6\040\ufef6\051" +
    "\ufef6\052\ufef6\055\ufef6\063\ufef6\064\ufef6\067\ufef6\070\ufef6" +
    "\071\ufef6\073\ufef6\074\ufef6\075\ufef6\076\ufef6\077\ufef6\100" +
    "\ufef6\101\ufef6\102\ufef6\103\ufef6\106\ufef6\110\ufef6\111\ufef6" +
    "\112\ufef6\001\002\000\004\101\012\001\002\000\004\065" +
    "\014\001\002\000\006\071\015\110\017\001\002\000\010" +
    "\070\ufffb\071\ufffb\110\ufffb\001\002\000\032\011\ufef4\013" +
    "\ufef4\015\ufef4\037\ufef4\065\ufef4\066\ufef4\072\ufef4\077\ufef4" +
    "\101\ufef4\107\ufef4\117\ufef4\120\ufef4\001\002\000\004\065" +
    "\020\001\002\000\004\063\ufffd\001\002\000\010\070\ufffc" +
    "\071\ufffc\110\ufffc\001\002\000\070\003\ufef5\005\ufef5\006" +
    "\ufef5\007\ufef5\013\ufef5\015\ufef5\024\ufef5\026\ufef5\027\ufef5" +
    "\030\ufef5\031\ufef5\032\ufef5\036\ufef5\042\ufef5\045\ufef5\047" +
    "\ufef5\053\ufef5\055\ufef5\057\ufef5\060\ufef5\061\ufef5\063\ufef5" +
    "\065\ufef5\066\ufef5\072\ufef5\107\ufef5\110\ufef5\001\002\000" +
    "\022\003\023\005\ufff4\007\ufff4\030\ufff4\036\024\042\ufff4" +
    "\053\ufff4\057\ufff4\001\002\000\004\063\ufff6\001\002\000" +
    "\004\072\254\001\002\000\016\005\uffef\007\030\030\uffef" +
    "\042\uffef\053\uffef\057\uffef\001\002\000\004\064\027\001" +
    "\002\000\004\002\001\001\002\000\006\003\u0181\065\010" +
    "\001\002\000\014\005\uffd2\030\uffd2\042\uffd2\053\033\057" +
    "\uffd2\001\002\000\012\005\uff95\030\uff95\042\uff95\057\211" +
    "\001\002\000\006\003\036\065\010\001\002\000\004\074" +
    "\043\001\002\000\016\003\uffd0\005\uffd0\030\uffd0\042\uffd0" +
    "\057\uffd0\065\uffd0\001\002\000\004\063\uffce\001\002\000" +
    "\016\003\036\005\uffd3\030\uffd3\042\uffd3\057\uffd3\065\010" +
    "\001\002\000\016\003\uffd1\005\uffd1\030\uffd1\042\uffd1\057" +
    "\uffd1\065\uffd1\001\002\000\004\063\021\001\002\000\016" +
    "\003\uffcd\005\uffcd\030\uffcd\042\uffcd\057\uffcd\065\uffcd\001" +
    "\002\000\046\004\101\013\073\015\044\041\055\044\072" +
    "\046\070\050\065\065\056\066\050\072\105\101\061\105" +
    "\066\107\077\112\063\113\075\114\064\115\100\116\051" +
    "\001\002\000\032\011\uffd8\013\uffd8\015\uffd8\037\uffd8\065" +
    "\uffd8\066\uffd8\072\uffd8\077\uffd8\101\uffd8\107\uffd8\117\uffd8" +
    "\120\uffd8\001\002\000\020\024\uffd5\063\uffd5\070\uffd5\071" +
    "\uffd5\073\uffd5\106\uffd5\110\uffd5\001\002\000\004\073\207" +
    "\001\002\000\010\024\uffb9\063\uffb9\110\uffb9\001\002\000" +
    "\020\024\uffd9\063\uffd9\070\uffd9\071\uffd9\073\uffd9\106\uffd9" +
    "\110\uffd9\001\002\000\010\024\uffc8\063\uffc8\110\uffc8\001" +
    "\002\000\020\024\uffdb\063\uffdb\070\uffdb\071\uffdb\073\uffdb" +
    "\106\uffdb\110\uffdb\001\002\000\010\024\uffc3\063\uffc3\110" +
    "\uffc3\001\002\000\014\024\uffc2\063\uffc2\071\uffc2\106\uffc2" +
    "\110\uffc2\001\002\000\012\004\101\044\072\046\070\105" +
    "\066\001\002\000\012\024\uffcc\063\uffcc\073\ufef6\110\uffcc" +
    "\001\002\000\010\024\uffc4\063\uffc4\110\uffc4\001\002\000" +
    "\010\024\uffcb\063\uffcb\110\uffcb\001\002\000\004\065\014" +
    "\001\002\000\010\024\uffbb\063\uffbb\110\uffbb\001\002\000" +
    "\004\065\010\001\002\000\010\024\uffc6\063\uffc6\110\uffc6" +
    "\001\002\000\010\024\uffca\063\uffca\110\uffca\001\002\000" +
    "\004\040\200\001\002\000\014\024\uffc1\063\uffc1\071\uffc1" +
    "\106\uffc1\110\uffc1\001\002\000\004\040\175\001\002\000" +
    "\010\024\uffc5\063\uffc5\110\uffc5\001\002\000\010\006\130" +
    "\024\uffa9\065\014\001\002\000\032\011\uffd7\013\uffd7\015" +
    "\uffd7\037\uffd7\065\uffd7\066\uffd7\072\uffd7\077\uffd7\101\uffd7" +
    "\107\uffd7\117\uffd7\120\uffd7\001\002\000\004\063\021\001" +
    "\002\000\010\024\uffc9\063\uffc9\110\uffc9\001\002\000\010" +
    "\024\uffbc\063\uffbc\110\uffbc\001\002\000\020\024\uffd4\063" +
    "\uffd4\070\uffd4\071\uffd4\073\uffd4\106\uffd4\110\uffd4\001\002" +
    "\000\010\024\uffc7\063\uffc7\110\uffc7\001\002\000\004\077" +
    "\107\001\002\000\010\065\010\072\105\107\077\001\002" +
    "\000\010\024\uffbe\063\uffbe\110\uffbe\001\002\000\010\024" +
    "\uffba\063\uffba\110\uffba\001\002\000\020\024\uffd6\063\uffd6" +
    "\070\uffd6\071\uffd6\073\uffd6\106\uffd6\110\uffd6\001\002\000" +
    "\020\024\uffda\063\uffda\070\uffda\071\uffda\073\uffda\106\uffda" +
    "\110\uffda\001\002\000\020\013\073\015\044\065\010\066" +
    "\050\072\105\101\061\107\077\001\002\000\006\071\uffb5" +
    "\106\uffb5\001\002\000\016\024\uffb3\063\uffb3\071\uffb3\073" +
    "\uffd5\106\uffb3\110\uffb3\001\002\000\006\071\015\106\116" +
    "\001\002\000\006\071\uffb6\106\uffb6\001\002\000\014\024" +
    "\uffb4\063\uffb4\071\uffb4\106\uffb4\110\uffb4\001\002\000\020" +
    "\013\073\015\044\065\010\066\050\072\105\101\061\107" +
    "\077\001\002\000\004\040\117\001\002\000\046\004\101" +
    "\013\073\015\044\041\055\044\072\046\070\050\065\065" +
    "\056\066\050\072\105\101\061\105\066\107\077\112\063" +
    "\113\075\114\064\115\100\116\051\001\002\000\010\024" +
    "\uffb2\063\uffb2\110\uffb2\001\002\000\010\024\uffb8\063\uffb8" +
    "\110\uffb8\001\002\000\006\071\uffb7\106\uffb7\001\002\000" +
    "\016\003\uffcf\005\uffcf\030\uffcf\042\uffcf\057\uffcf\065\uffcf" +
    "\001\002\000\004\024\174\001\002\000\010\024\uffad\063" +
    "\uffad\110\uffad\001\002\000\006\070\172\071\015\001\002" +
    "\000\006\024\167\063\021\001\002\000\004\065\010\001" +
    "\002\000\004\040\uffa7\001\002\000\004\070\163\001\002" +
    "\000\004\040\135\001\002\000\006\040\uff9c\070\uff9d\001" +
    "\002\000\016\013\073\015\044\065\010\066\050\072\105" +
    "\107\077\001\002\000\006\070\150\071\015\001\002\000" +
    "\010\024\uffa5\063\uffa5\110\uffa5\001\002\000\010\024\uffaa" +
    "\063\021\110\uffaa\001\002\000\010\070\uff9f\071\uff9f\073" +
    "\143\001\002\000\006\070\uffa0\071\uffa0\001\002\000\016" +
    "\013\073\015\044\065\010\066\050\072\105\107\077\001" +
    "\002\000\006\070\uff9e\071\uff9e\001\002\000\022\013\073" +
    "\015\044\024\uffab\065\010\066\050\072\105\107\077\110" +
    "\uffab\001\002\000\010\024\uffa6\063\uffa6\110\uffa6\001\002" +
    "\000\016\013\073\015\044\065\010\066\050\072\105\107" +
    "\077\001\002\000\004\101\151\001\002\000\010\006\130" +
    "\065\014\110\uffa9\001\002\000\004\110\161\001\002\000" +
    "\006\063\021\110\154\001\002\000\010\024\uffa4\063\uffa4" +
    "\110\uffa4\001\002\000\010\006\130\065\014\110\uffa9\001" +
    "\002\000\004\110\160\001\002\000\010\024\uffae\063\uffae" +
    "\110\uffae\001\002\000\010\024\uffa3\063\uffa3\110\uffa3\001" +
    "\002\000\010\024\uffa2\063\uffa2\110\uffa2\001\002\000\006" +
    "\070\uffa1\071\uffa1\001\002\000\004\065\010\001\002\000" +
    "\004\040\uffa8\001\002\000\004\040\uff9c\001\002\000\010" +
    "\006\130\024\uffa9\065\014\001\002\000\010\024\uffb1\063" +
    "\uffb1\110\uffb1\001\002\000\004\024\171\001\002\000\010" +
    "\024\uffb0\063\uffb0\110\uffb0\001\002\000\046\004\101\013" +
    "\073\015\044\041\055\044\072\046\070\050\065\065\056" +
    "\066\050\072\105\101\061\105\066\107\077\112\063\113" +
    "\075\114\064\115\100\116\051\001\002\000\010\024\uffac" +
    "\063\uffac\110\uffac\001\002\000\010\024\uffaf\063\uffaf\110" +
    "\uffaf\001\002\000\020\013\073\015\044\065\010\066\050" +
    "\072\105\101\061\107\077\001\002\000\010\024\uff9a\063" +
    "\uff9a\110\uff9a\001\002\000\010\024\uff9b\063\uff9b\110\uff9b" +
    "\001\002\000\046\004\101\013\073\015\044\041\055\044" +
    "\072\046\070\050\065\065\056\066\050\072\105\101\061" +
    "\105\066\107\077\112\063\113\075\114\064\115\100\116" +
    "\051\001\002\000\010\024\uff99\063\uff99\110\uff99\001\002" +
    "\000\010\024\uff97\063\uff97\110\uff97\001\002\000\010\024" +
    "\uff98\063\uff98\110\uff98\001\002\000\006\071\015\110\205" +
    "\001\002\000\014\024\uffc0\063\uffc0\071\uffc0\106\uffc0\110" +
    "\uffc0\001\002\000\010\024\uffbd\063\uffbd\110\uffbd\001\002" +
    "\000\016\013\073\015\044\065\010\066\050\072\105\107" +
    "\077\001\002\000\014\024\uffbf\063\uffbf\071\uffbf\106\uffbf" +
    "\110\uffbf\001\002\000\006\003\u0178\065\014\001\002\000" +
    "\010\005\uff8e\030\223\042\216\001\002\000\006\063\021" +
    "\101\uff71\001\002\000\004\063\uff8a\001\002\000\004\063" +
    "\021\001\002\000\004\065\010\001\002\000\004\063\021" +
    "\001\002\000\010\063\uff87\101\uff86\110\uff87\001\002\000" +
    "\004\063\uff8c\001\002\000\004\063\uff8b\001\002\000\004" +
    "\065\010\001\002\000\004\005\ufffa\001\002\000\004\063" +
    "\021\001\002\000\010\005\uff8f\030\223\042\216\001\002" +
    "\000\004\063\uff8d\001\002\000\004\005\231\001\002\000" +
    "\032\005\231\006\244\024\uff58\026\252\031\270\032\260" +
    "\045\245\060\271\061\241\063\uff58\065\010\072\254\001" +
    "\002\000\006\063\uff6c\064\uff6c\001\002\000\006\063\ufff9" +
    "\064\ufff9\001\002\000\010\024\uff56\055\uff56\063\uff56\001" +
    "\002\000\106\010\uff43\012\uff43\013\uff43\014\uff43\015\uff43" +
    "\016\uff43\017\uff43\020\uff43\021\uff43\022\uff43\023\uff43\024" +
    "\uff43\034\uff43\040\uff43\051\uff43\052\uff43\055\uff43\063\uff43" +
    "\064\uff43\067\uff43\070\uff43\071\uff43\073\uff43\074\uff43\075" +
    "\uff43\076\uff43\077\uff43\100\uff43\102\uff43\103\uff43\106\uff43" +
    "\110\uff43\111\uff43\112\uff43\001\002\000\010\024\uff57\055" +
    "\uff57\063\uff57\001\002\000\010\024\uff67\055\uff67\063\uff67" +
    "\001\002\000\012\023\uff5b\024\uff5b\055\uff5b\063\uff5b\001" +
    "\002\000\004\065\010\001\002\000\010\024\uff68\055\uff68" +
    "\063\uff68\001\002\000\012\023\uff60\024\uff60\055\uff60\063" +
    "\uff60\001\002\000\032\011\310\013\073\015\044\037\313" +
    "\065\010\066\307\072\334\077\327\101\312\107\331\117" +
    "\311\120\324\001\002\000\032\005\uff53\006\uff53\026\uff53" +
    "\031\uff53\032\uff53\045\uff53\055\uff53\060\uff53\061\uff53\063" +
    "\uff53\065\uff53\072\uff53\001\002\000\004\021\u0130\001\002" +
    "\000\012\023\uff5f\024\uff5f\055\uff5f\063\uff5f\001\002\000" +
    "\004\021\u012d\001\002\000\012\023\uff5c\024\uff5c\055\uff5c" +
    "\063\uff5c\001\002\000\004\065\010\001\002\000\010\024" +
    "\uff55\055\uff55\063\uff55\001\002\000\016\023\ufff1\024\ufff1" +
    "\055\ufff1\063\ufff1\070\ufff1\071\ufff1\001\002\000\024\023" +
    "\uff3b\024\uff3b\055\uff3b\063\uff3b\064\uff45\067\uff45\077\uff45" +
    "\101\u0102\112\uff45\001\002\000\012\023\uff59\024\uff59\055" +
    "\uff59\063\uff59\001\002\000\012\023\uff62\024\uff62\055\uff62" +
    "\063\uff62\001\002\000\032\011\310\013\073\015\044\037" +
    "\313\065\010\066\307\072\334\077\327\101\312\107\331" +
    "\117\311\120\324\001\002\000\012\064\u0110\067\u0119\077" +
    "\u010e\112\u010f\001\002\000\012\023\uff5e\024\uff5e\055\uff5e" +
    "\063\uff5e\001\002\000\010\024\uff69\055\uff69\063\uff69\001" +
    "\002\000\012\023\uff63\024\uff63\055\uff63\063\uff63\001\002" +
    "\000\106\010\uff44\012\uff44\013\uff44\014\uff44\015\uff44\016" +
    "\uff44\017\uff44\020\uff44\021\uff44\022\uff44\023\uff44\024\uff44" +
    "\034\uff44\040\uff44\051\uff44\052\uff44\055\uff44\063\uff44\064" +
    "\uff44\067\uff44\070\uff44\071\uff44\073\uff44\074\uff44\075\uff44" +
    "\076\uff44\077\uff44\100\uff44\102\uff44\103\uff44\106\uff44\110" +
    "\uff44\111\uff44\112\uff44\001\002\000\012\023\uff61\024\uff61" +
    "\055\uff61\063\uff61\001\002\000\010\024\uff65\055\uff65\063" +
    "\uff65\001\002\000\004\072\254\001\002\000\032\011\310" +
    "\013\073\015\044\037\313\065\010\066\307\072\334\077" +
    "\327\101\312\107\331\117\311\120\324\001\002\000\004" +
    "\070\302\001\002\000\010\024\uff54\055\uff54\063\uff54\001" +
    "\002\000\012\023\uff5d\024\uff5d\055\uff5d\063\uff5d\001\002" +
    "\000\012\023\uff5a\024\uff5a\055\uff5a\063\uff5a\001\002\000" +
    "\006\024\300\063\021\001\002\000\034\005\231\006\244" +
    "\024\uff58\026\252\031\270\032\260\045\245\055\uff58\060" +
    "\271\061\241\063\uff58\065\010\072\254\001\002\000\014" +
    "\023\uff6b\024\uff6b\055\uff6b\063\uff6b\064\uff6b\001\002\000" +
    "\010\024\uff6a\055\uff6a\063\uff6a\001\002\000\034\005\231" +
    "\006\244\023\uff58\024\uff58\026\252\031\270\032\260\045" +
    "\245\055\uff58\060\271\061\241\063\uff58\065\010\001\002" +
    "\000\012\023\uff64\024\uff64\055\uff64\063\uff64\001\002\000" +
    "\010\024\uff66\055\uff66\063\uff66\001\002\000\104\010\uff1b" +
    "\012\uff1b\013\uff1b\014\uff1b\015\uff1b\016\uff1b\017\uff1b\020" +
    "\uff1b\021\uff1b\022\uff1b\023\uff1b\024\uff1b\034\uff1b\040\uff1b" +
    "\051\uff1b\052\uff1b\055\uff1b\063\uff1b\064\u0110\070\uff1b\071" +
    "\uff1b\073\uff1b\074\uff1b\075\uff1b\076\uff1b\077\u010e\100\uff1b" +
    "\102\uff1b\103\uff1b\106\uff1b\110\uff1b\111\uff1b\112\u010f\001" +
    "\002\000\106\010\uff45\012\uff45\013\uff45\014\uff45\015\uff45" +
    "\016\uff45\017\uff45\020\uff45\021\uff45\022\uff45\023\uff45\024" +
    "\uff45\034\uff45\040\uff45\051\uff45\052\uff45\055\uff45\063\uff45" +
    "\064\uff45\070\uff45\071\uff45\073\uff45\074\uff45\075\uff45\076" +
    "\uff45\077\uff45\100\uff45\101\u0102\102\uff45\103\uff45\106\uff45" +
    "\110\uff45\111\uff45\112\uff45\001\002\000\076\010\uff12\012" +
    "\uff12\013\uff12\014\uff12\015\uff12\016\uff12\017\uff12\020\uff12" +
    "\021\uff12\022\uff12\023\uff12\024\uff12\034\uff12\040\uff12\051" +
    "\uff12\052\uff12\055\uff12\063\uff12\070\uff12\071\uff12\073\uff12" +
    "\074\uff12\075\uff12\076\uff12\100\uff12\102\uff12\103\uff12\106" +
    "\uff12\110\uff12\111\uff12\001\002\000\026\011\310\037\313" +
    "\065\010\066\307\072\334\077\327\101\312\107\331\117" +
    "\311\120\324\001\002\000\076\010\uff15\012\uff15\013\uff15" +
    "\014\uff15\015\uff15\016\uff15\017\uff15\020\uff15\021\uff15\022" +
    "\uff15\023\uff15\024\uff15\034\uff15\040\uff15\051\uff15\052\uff15" +
    "\055\uff15\063\uff15\070\uff15\071\uff15\073\uff15\074\uff15\075" +
    "\uff15\076\uff15\100\uff15\102\uff15\103\uff15\106\uff15\110\uff15" +
    "\111\uff15\001\002\000\032\011\310\013\073\015\044\037" +
    "\313\065\010\066\307\072\334\077\327\101\312\107\331" +
    "\117\311\120\324\001\002\000\076\010\uff11\012\uff11\013" +
    "\uff11\014\uff11\015\uff11\016\uff11\017\uff11\020\uff11\021\uff11" +
    "\022\uff11\023\uff11\024\uff11\034\uff11\040\uff11\051\uff11\052" +
    "\uff11\055\uff11\063\uff11\070\uff11\071\uff11\073\uff11\074\uff11" +
    "\075\uff11\076\uff11\100\uff11\102\uff11\103\uff11\106\uff11\110" +
    "\uff11\111\uff11\001\002\000\074\010\uff1e\012\uff1e\013\uff1e" +
    "\014\uff1e\015\uff1e\016\uff1e\017\uff1e\020\uff1e\021\uff1e\022" +
    "\uff1e\023\uff1e\024\uff1e\034\uff1e\040\uff1e\051\uff1e\052\uff1e" +
    "\055\uff1e\063\uff1e\070\uff1e\071\uff1e\073\uff1e\074\uff1e\075" +
    "\uff1e\076\uff1e\100\uff1e\102\uff1e\103\uff1e\106\uff1e\110\uff1e" +
    "\001\002\000\016\021\uff26\023\uff26\024\uff26\051\uff26\055" +
    "\uff26\063\uff26\001\002\000\076\010\uff10\012\uff10\013\uff10" +
    "\014\uff10\015\uff10\016\uff10\017\uff10\020\uff10\021\uff10\022" +
    "\uff10\023\uff10\024\uff10\034\uff10\040\uff10\051\uff10\052\uff10" +
    "\055\uff10\063\uff10\070\uff10\071\uff10\073\uff10\074\uff10\075" +
    "\uff10\076\uff10\100\uff10\102\uff10\103\uff10\106\uff10\110\uff10" +
    "\111\uff10\001\002\000\074\010\uff21\012\uff21\013\uff21\014" +
    "\uff21\015\uff21\016\uff21\017\uff21\020\uff21\021\uff21\022\uff21" +
    "\023\uff21\024\uff21\034\uff21\040\uff21\051\uff21\052\uff21\055" +
    "\uff21\063\uff21\070\uff21\071\uff21\073\uff21\074\uff21\075\uff21" +
    "\076\uff21\100\uff21\102\uff21\103\uff21\106\uff21\110\uff21\001" +
    "\002\000\074\010\372\012\uff23\013\uff23\014\367\015\uff23" +
    "\016\374\017\370\020\373\021\uff23\022\uff23\023\uff23\024" +
    "\uff23\034\uff23\040\uff23\051\uff23\052\uff23\055\uff23\063\uff23" +
    "\070\uff23\071\uff23\073\uff23\074\uff23\075\uff23\076\uff23\100" +
    "\uff23\102\uff23\103\uff23\106\uff23\110\uff23\001\002\000\076" +
    "\010\uff18\012\uff18\013\uff18\014\uff18\015\uff18\016\uff18\017" +
    "\uff18\020\uff18\021\uff18\022\uff18\023\uff18\024\uff18\034\uff18" +
    "\040\uff18\051\uff18\052\uff18\055\uff18\063\uff18\070\uff18\071" +
    "\uff18\073\uff18\074\uff18\075\uff18\076\uff18\100\uff18\102\uff18" +
    "\103\uff18\106\uff18\110\uff18\111\uff18\001\002\000\076\010" +
    "\uff1a\012\uff1a\013\uff1a\014\uff1a\015\uff1a\016\uff1a\017\uff1a" +
    "\020\uff1a\021\uff1a\022\uff1a\023\uff1a\024\uff1a\034\uff1a\040" +
    "\uff1a\051\uff1a\052\uff1a\055\uff1a\063\uff1a\070\uff1a\071\uff1a" +
    "\073\uff1a\074\uff1a\075\uff1a\076\uff1a\100\uff1a\102\uff1a\103" +
    "\uff1a\106\uff1a\110\uff1a\111\uff1a\001\002\000\062\012\365" +
    "\013\352\015\357\021\uff25\022\uff25\023\uff25\024\uff25\034" +
    "\354\040\uff25\051\uff25\052\uff25\055\uff25\063\uff25\070\uff25" +
    "\071\uff25\073\uff25\074\356\075\355\076\361\100\360\102" +
    "\364\103\353\106\uff25\110\uff25\001\002\000\076\010\uff14" +
    "\012\uff14\013\uff14\014\uff14\015\uff14\016\uff14\017\uff14\020" +
    "\uff14\021\uff14\022\uff14\023\uff14\024\uff14\034\uff14\040\uff14" +
    "\051\uff14\052\uff14\055\uff14\063\uff14\070\uff14\071\uff14\073" +
    "\uff14\074\uff14\075\uff14\076\uff14\100\uff14\102\uff14\103\uff14" +
    "\106\uff14\110\uff14\111\uff14\001\002\000\076\010\uff1d\012" +
    "\uff1d\013\uff1d\014\uff1d\015\uff1d\016\uff1d\017\uff1d\020\uff1d" +
    "\021\uff1d\022\uff1d\023\uff1d\024\uff1d\034\uff1d\040\uff1d\051" +
    "\uff1d\052\uff1d\055\uff1d\063\uff1d\070\uff1d\071\uff1d\073\uff1d" +
    "\074\uff1d\075\uff1d\076\uff1d\100\uff1d\102\uff1d\103\uff1d\106" +
    "\uff1d\110\uff1d\111\350\001\002\000\076\010\uff13\012\uff13" +
    "\013\uff13\014\uff13\015\uff13\016\uff13\017\uff13\020\uff13\021" +
    "\uff13\022\uff13\023\uff13\024\uff13\034\uff13\040\uff13\051\uff13" +
    "\052\uff13\055\uff13\063\uff13\070\uff13\071\uff13\073\uff13\074" +
    "\uff13\075\uff13\076\uff13\100\uff13\102\uff13\103\uff13\106\uff13" +
    "\110\uff13\111\uff13\001\002\000\034\011\310\013\073\015" +
    "\044\037\313\065\010\066\307\072\334\077\327\101\312" +
    "\106\340\107\331\117\311\120\324\001\002\000\076\010" +
    "\uff19\012\uff19\013\uff19\014\uff19\015\uff19\016\uff19\017\uff19" +
    "\020\uff19\021\uff19\022\uff19\023\uff19\024\uff19\034\uff19\040" +
    "\uff19\051\uff19\052\uff19\055\uff19\063\uff19\070\uff19\071\uff19" +
    "\073\uff19\074\uff19\075\uff19\076\uff19\100\uff19\102\uff19\103" +
    "\uff19\106\uff19\110\uff19\111\uff19\001\002\000\076\010\uff0d" +
    "\012\uff0d\013\uff0d\014\uff0d\015\uff0d\016\uff0d\017\uff0d\020" +
    "\uff0d\021\uff0d\022\uff0d\023\uff0d\024\uff0d\034\uff0d\040\uff0d" +
    "\051\uff0d\052\uff0d\055\uff0d\063\uff0d\070\uff0d\071\uff0d\073" +
    "\uff0d\074\uff0d\075\uff0d\076\uff0d\100\uff0d\102\uff0d\103\uff0d" +
    "\106\uff0d\110\uff0d\111\uff0d\001\002\000\004\021\uff51\001" +
    "\002\000\032\011\310\013\073\015\044\037\313\065\010" +
    "\066\307\072\334\077\327\101\312\107\331\117\311\120" +
    "\324\001\002\000\076\010\uff0e\012\uff0e\013\uff0e\014\uff0e" +
    "\015\uff0e\016\uff0e\017\uff0e\020\uff0e\021\uff0e\022\uff0e\023" +
    "\uff0e\024\uff0e\034\uff0e\040\uff0e\051\uff0e\052\uff0e\055\uff0e" +
    "\063\uff0e\070\uff0e\071\uff0e\073\uff0e\074\uff0e\075\uff0e\076" +
    "\uff0e\100\uff0e\102\uff0e\103\uff0e\106\uff0e\110\uff0e\111\uff0e" +
    "\001\002\000\076\010\uff0f\012\uff0f\013\uff0f\014\uff0f\015" +
    "\uff0f\016\uff0f\017\uff0f\020\uff0f\021\uff0f\022\uff0f\023\uff0f" +
    "\024\uff0f\034\uff0f\040\uff0f\051\uff0f\052\uff0f\055\uff0f\063" +
    "\uff0f\070\uff0f\071\uff0f\073\uff0f\074\uff0f\075\uff0f\076\uff0f" +
    "\100\uff0f\102\uff0f\103\uff0f\106\uff0f\110\uff0f\111\uff0f\001" +
    "\002\000\074\010\uff1f\012\uff1f\013\uff1f\014\uff1f\015\uff1f" +
    "\016\uff1f\017\uff1f\020\uff1f\021\uff1f\022\uff1f\023\uff1f\024" +
    "\uff1f\034\uff1f\040\uff1f\051\uff1f\052\uff1f\055\uff1f\063\uff1f" +
    "\070\uff1f\071\uff1f\073\uff1f\074\uff1f\075\uff1f\076\uff1f\100" +
    "\uff1f\102\uff1f\103\uff1f\106\uff1f\110\uff1f\001\002\000\010" +
    "\071\uff08\073\346\106\uff08\001\002\000\076\010\uff0a\012" +
    "\uff0a\013\uff0a\014\uff0a\015\uff0a\016\uff0a\017\uff0a\020\uff0a" +
    "\021\uff0a\022\uff0a\023\uff0a\024\uff0a\034\uff0a\040\uff0a\051" +
    "\uff0a\052\uff0a\055\uff0a\063\uff0a\070\uff0a\071\uff0a\073\uff0a" +
    "\074\uff0a\075\uff0a\076\uff0a\100\uff0a\102\uff0a\103\uff0a\106" +
    "\uff0a\110\uff0a\111\uff0a\001\002\000\010\071\uff06\073\uff06" +
    "\106\uff06\001\002\000\006\071\015\106\344\001\002\000" +
    "\032\011\310\013\073\015\044\037\313\065\010\066\307" +
    "\072\334\077\327\101\312\107\331\117\311\120\324\001" +
    "\002\000\076\010\uff0b\012\uff0b\013\uff0b\014\uff0b\015\uff0b" +
    "\016\uff0b\017\uff0b\020\uff0b\021\uff0b\022\uff0b\023\uff0b\024" +
    "\uff0b\034\uff0b\040\uff0b\051\uff0b\052\uff0b\055\uff0b\063\uff0b" +
    "\070\uff0b\071\uff0b\073\uff0b\074\uff0b\075\uff0b\076\uff0b\100" +
    "\uff0b\102\uff0b\103\uff0b\106\uff0b\110\uff0b\111\uff0b\001\002" +
    "\000\010\071\uff09\073\346\106\uff09\001\002\000\032\011" +
    "\310\013\073\015\044\037\313\065\010\066\307\072\334" +
    "\077\327\101\312\107\331\117\311\120\324\001\002\000" +
    "\010\071\uff07\073\uff07\106\uff07\001\002\000\026\011\310" +
    "\037\313\065\010\066\307\072\334\077\327\101\312\107" +
    "\331\117\311\120\324\001\002\000\074\010\uff1c\012\uff1c" +
    "\013\uff1c\014\uff1c\015\uff1c\016\uff1c\017\uff1c\020\uff1c\021" +
    "\uff1c\022\uff1c\023\uff1c\024\uff1c\034\uff1c\040\uff1c\051\uff1c" +
    "\052\uff1c\055\uff1c\063\uff1c\070\uff1c\071\uff1c\073\uff1c\074" +
    "\uff1c\075\uff1c\076\uff1c\100\uff1c\102\uff1c\103\uff1c\106\uff1c" +
    "\110\uff1c\001\002\000\032\011\uff04\013\uff04\015\uff04\037" +
    "\uff04\065\uff04\066\uff04\072\uff04\077\uff04\101\uff04\107\uff04" +
    "\117\uff04\120\uff04\001\002\000\032\011\ufefc\013\ufefc\015" +
    "\ufefc\037\ufefc\065\ufefc\066\ufefc\072\ufefc\077\ufefc\101\ufefc" +
    "\107\ufefc\117\ufefc\120\ufefc\001\002\000\032\011\ufef7\013" +
    "\ufef7\015\ufef7\037\ufef7\065\ufef7\066\ufef7\072\ufef7\077\ufef7" +
    "\101\ufef7\107\ufef7\117\ufef7\120\ufef7\001\002\000\032\011" +
    "\ufef8\013\ufef8\015\ufef8\037\ufef8\065\ufef8\066\ufef8\072\ufef8" +
    "\077\ufef8\101\ufef8\107\ufef8\117\ufef8\120\ufef8\001\002\000" +
    "\032\011\ufefd\013\ufefd\015\ufefd\037\ufefd\065\ufefd\066\ufefd" +
    "\072\ufefd\077\ufefd\101\ufefd\107\ufefd\117\ufefd\120\ufefd\001" +
    "\002\000\032\011\uff05\013\uff05\015\uff05\037\uff05\065\uff05" +
    "\066\uff05\072\uff05\077\uff05\101\uff05\107\uff05\117\uff05\120" +
    "\uff05\001\002\000\032\011\ufef9\013\ufef9\015\ufef9\037\ufef9" +
    "\065\ufef9\066\ufef9\072\ufef9\077\ufef9\101\ufef9\107\ufef9\117" +
    "\ufef9\120\ufef9\001\002\000\032\011\ufefa\013\ufefa\015\ufefa" +
    "\037\ufefa\065\ufefa\066\ufefa\072\ufefa\077\ufefa\101\ufefa\107" +
    "\ufefa\117\ufefa\120\ufefa\001\002\000\032\011\310\013\073" +
    "\015\044\037\313\065\010\066\307\072\334\077\327\101" +
    "\312\107\331\117\311\120\324\001\002\000\032\011\310" +
    "\013\073\015\044\037\313\065\010\066\307\072\334\077" +
    "\327\101\312\107\331\117\311\120\324\001\002\000\032" +
    "\011\ufefb\013\ufefb\015\ufefb\037\ufefb\065\ufefb\066\ufefb\072" +
    "\ufefb\077\ufefb\101\ufefb\107\ufefb\117\ufefb\120\ufefb\001\002" +
    "\000\032\011\uff03\013\uff03\015\uff03\037\uff03\065\uff03\066" +
    "\uff03\072\uff03\077\uff03\101\uff03\107\uff03\117\uff03\120\uff03" +
    "\001\002\000\074\010\372\012\uff22\013\uff22\014\367\015" +
    "\uff22\016\374\017\370\020\373\021\uff22\022\uff22\023\uff22" +
    "\024\uff22\034\uff22\040\uff22\051\uff22\052\uff22\055\uff22\063" +
    "\uff22\070\uff22\071\uff22\073\uff22\074\uff22\075\uff22\076\uff22" +
    "\100\uff22\102\uff22\103\uff22\106\uff22\110\uff22\001\002\000" +
    "\032\011\uff02\013\uff02\015\uff02\037\uff02\065\uff02\066\uff02" +
    "\072\uff02\077\uff02\101\uff02\107\uff02\117\uff02\120\uff02\001" +
    "\002\000\032\011\ufeff\013\ufeff\015\ufeff\037\ufeff\065\ufeff" +
    "\066\ufeff\072\ufeff\077\ufeff\101\ufeff\107\ufeff\117\ufeff\120" +
    "\ufeff\001\002\000\032\011\310\013\073\015\044\037\313" +
    "\065\010\066\307\072\334\077\327\101\312\107\331\117" +
    "\311\120\324\001\002\000\032\011\ufefe\013\ufefe\015\ufefe" +
    "\037\ufefe\065\ufefe\066\ufefe\072\ufefe\077\ufefe\101\ufefe\107" +
    "\ufefe\117\ufefe\120\ufefe\001\002\000\032\011\uff01\013\uff01" +
    "\015\uff01\037\uff01\065\uff01\066\uff01\072\uff01\077\uff01\101" +
    "\uff01\107\uff01\117\uff01\120\uff01\001\002\000\032\011\uff00" +
    "\013\uff00\015\uff00\037\uff00\065\uff00\066\uff00\072\uff00\077" +
    "\uff00\101\uff00\107\uff00\117\uff00\120\uff00\001\002\000\074" +
    "\010\uff20\012\uff20\013\uff20\014\uff20\015\uff20\016\uff20\017" +
    "\uff20\020\uff20\021\uff20\022\uff20\023\uff20\024\uff20\034\uff20" +
    "\040\uff20\051\uff20\052\uff20\055\uff20\063\uff20\070\uff20\071" +
    "\uff20\073\uff20\074\uff20\075\uff20\076\uff20\100\uff20\102\uff20" +
    "\103\uff20\106\uff20\110\uff20\001\002\000\044\012\365\013" +
    "\352\015\357\021\uff24\022\uff24\023\uff24\024\uff24\040\uff24" +
    "\051\uff24\052\uff24\055\uff24\063\uff24\070\uff24\071\uff24\073" +
    "\uff24\106\uff24\110\uff24\001\002\000\004\110\u0100\001\002" +
    "\000\076\010\uff17\012\uff17\013\uff17\014\uff17\015\uff17\016" +
    "\uff17\017\uff17\020\uff17\021\uff17\022\uff17\023\uff17\024\uff17" +
    "\034\uff17\040\uff17\051\uff17\052\uff17\055\uff17\063\uff17\070" +
    "\uff17\071\uff17\073\uff17\074\uff17\075\uff17\076\uff17\100\uff17" +
    "\102\uff17\103\uff17\106\uff17\110\uff17\111\uff17\001\002\000" +
    "\076\010\uff16\012\uff16\013\uff16\014\uff16\015\uff16\016\uff16" +
    "\017\uff16\020\uff16\021\uff16\022\uff16\023\uff16\024\uff16\034" +
    "\uff16\040\uff16\051\uff16\052\uff16\055\uff16\063\uff16\070\uff16" +
    "\071\uff16\073\uff16\074\uff16\075\uff16\076\uff16\100\uff16\102" +
    "\uff16\103\uff16\106\uff16\110\uff16\111\uff16\001\002\000\032" +
    "\011\310\013\073\015\044\037\313\065\010\066\307\072" +
    "\334\077\327\101\312\107\331\117\311\120\324\001\002" +
    "\000\076\010\uff0c\012\uff0c\013\uff0c\014\uff0c\015\uff0c\016" +
    "\uff0c\017\uff0c\020\uff0c\021\uff0c\022\uff0c\023\uff0c\024\uff0c" +
    "\034\uff0c\040\uff0c\051\uff0c\052\uff0c\055\uff0c\063\uff0c\070" +
    "\uff0c\071\uff0c\073\uff0c\074\uff0c\075\uff0c\076\uff0c\100\uff0c" +
    "\102\uff0c\103\uff0c\106\uff0c\110\uff0c\111\uff0c\001\002\000" +
    "\006\071\uff38\110\uff38\001\002\000\010\070\u010a\071\uff37" +
    "\110\uff37\001\002\000\006\071\015\110\u0108\001\002\000" +
    "\032\011\310\013\073\015\044\037\313\065\010\066\307" +
    "\072\334\077\327\101\312\107\331\117\311\120\324\001" +
    "\002\000\076\010\uff3a\012\uff3a\013\uff3a\014\uff3a\015\uff3a" +
    "\016\uff3a\017\uff3a\020\uff3a\021\uff3a\022\uff3a\023\uff3a\024" +
    "\uff3a\034\uff3a\040\uff3a\051\uff3a\052\uff3a\055\uff3a\063\uff3a" +
    "\070\uff3a\071\uff3a\073\uff3a\074\uff3a\075\uff3a\076\uff3a\100" +
    "\uff3a\102\uff3a\103\uff3a\106\uff3a\110\uff3a\111\uff3a\001\002" +
    "\000\006\071\uff39\110\uff39\001\002\000\032\011\310\013" +
    "\073\015\044\037\313\065\010\066\307\072\334\077\327" +
    "\101\312\107\331\117\311\120\324\001\002\000\010\070" +
    "\u010c\071\uff36\110\uff36\001\002\000\032\011\310\013\073" +
    "\015\044\037\313\065\010\066\307\072\334\077\327\101" +
    "\312\107\331\117\311\120\324\001\002\000\006\071\uff35" +
    "\110\uff35\001\002\000\032\011\310\013\073\015\044\037" +
    "\313\065\010\066\307\072\334\077\327\101\312\107\331" +
    "\117\311\120\324\001\002\000\106\010\uff42\012\uff42\013" +
    "\uff42\014\uff42\015\uff42\016\uff42\017\uff42\020\uff42\021\uff42" +
    "\022\uff42\023\uff42\024\uff42\034\uff42\040\uff42\051\uff42\052" +
    "\uff42\055\uff42\063\uff42\064\uff42\067\uff42\070\uff42\071\uff42" +
    "\073\uff42\074\uff42\075\uff42\076\uff42\077\uff42\100\uff42\102" +
    "\uff42\103\uff42\106\uff42\110\uff42\111\uff42\112\uff42\001\002" +
    "\000\004\065\010\001\002\000\106\010\uff3d\012\uff3d\013" +
    "\uff3d\014\uff3d\015\uff3d\016\uff3d\017\uff3d\020\uff3d\021\uff3d" +
    "\022\uff3d\023\uff3d\024\uff3d\034\uff3d\040\uff3d\051\uff3d\052" +
    "\uff3d\055\uff3d\063\uff3d\064\uff3d\067\uff3d\070\uff3d\071\uff3d" +
    "\073\uff3d\074\uff3d\075\uff3d\076\uff3d\077\uff3d\100\uff3d\102" +
    "\uff3d\103\uff3d\106\uff3d\110\uff3d\111\uff3d\112\uff3d\001\002" +
    "\000\006\071\015\106\u0116\001\002\000\006\071\uff3e\106" +
    "\uff3e\001\002\000\006\071\uff3f\106\uff3f\001\002\000\032" +
    "\011\310\013\073\015\044\037\313\065\010\066\307\072" +
    "\334\077\327\101\312\107\331\117\311\120\324\001\002" +
    "\000\106\010\uff41\012\uff41\013\uff41\014\uff41\015\uff41\016" +
    "\uff41\017\uff41\020\uff41\021\uff41\022\uff41\023\uff41\024\uff41" +
    "\034\uff41\040\uff41\051\uff41\052\uff41\055\uff41\063\uff41\064" +
    "\uff41\067\uff41\070\uff41\071\uff41\073\uff41\074\uff41\075\uff41" +
    "\076\uff41\077\uff41\100\uff41\102\uff41\103\uff41\106\uff41\110" +
    "\uff41\111\uff41\112\uff41\001\002\000\006\071\uff40\106\uff40" +
    "\001\002\000\012\023\uff34\024\uff34\055\uff34\063\uff34\001" +
    "\002\000\032\011\310\013\073\015\044\037\313\065\010" +
    "\066\307\072\334\077\327\101\312\107\331\117\311\120" +
    "\324\001\002\000\012\023\uff46\024\uff46\055\uff46\063\uff46" +
    "\001\002\000\004\051\u011c\001\002\000\036\005\231\006" +
    "\244\023\uff58\024\uff58\026\252\031\270\032\260\045\245" +
    "\055\uff58\060\271\061\241\063\uff58\065\010\072\254\001" +
    "\002\000\012\023\u011f\024\uff67\055\uff67\063\uff67\001\002" +
    "\000\010\024\uff49\055\uff49\063\uff49\001\002\000\036\005" +
    "\231\006\244\023\uff58\024\uff58\026\252\031\270\032\260" +
    "\045\245\055\uff58\060\271\061\241\063\uff58\065\010\072" +
    "\254\001\002\000\010\024\uff48\055\uff48\063\uff48\001\002" +
    "\000\012\023\uff47\024\uff47\055\uff47\063\uff47\001\002\000" +
    "\012\023\uff3c\024\uff3c\055\uff3c\063\uff3c\001\002\000\004" +
    "\067\uff2d\001\002\000\004\067\u0125\001\002\000\032\011" +
    "\310\013\073\015\044\037\313\065\010\066\307\072\334" +
    "\077\327\101\312\107\331\117\311\120\324\001\002\000" +
    "\006\022\uff2c\052\uff2c\001\002\000\006\022\u012a\052\u0128" +
    "\001\002\000\032\011\uff2b\013\uff2b\015\uff2b\037\uff2b\065" +
    "\uff2b\066\uff2b\072\uff2b\077\uff2b\101\uff2b\107\uff2b\117\uff2b" +
    "\120\uff2b\001\002\000\032\011\310\013\073\015\044\037" +
    "\313\065\010\066\307\072\334\077\327\101\312\107\331" +
    "\117\311\120\324\001\002\000\032\011\uff2a\013\uff2a\015" +
    "\uff2a\037\uff2a\065\uff2a\066\uff2a\072\uff2a\077\uff2a\101\uff2a" +
    "\107\uff2a\117\uff2a\120\uff2a\001\002\000\004\021\uff29\001" +
    "\002\000\004\021\uff4e\001\002\000\036\005\231\006\244" +
    "\023\uff58\024\uff58\026\252\031\270\032\260\045\245\055" +
    "\uff58\060\271\061\241\063\uff58\065\010\072\254\001\002" +
    "\000\010\024\uff50\055\uff50\063\uff50\001\002\000\012\023" +
    "\uff4f\024\uff4f\055\uff4f\063\uff4f\001\002\000\036\005\231" +
    "\006\244\023\uff58\024\uff58\026\252\031\270\032\260\045" +
    "\245\055\uff58\060\271\061\241\063\uff58\065\010\072\254" +
    "\001\002\000\010\024\uff4d\055\uff4d\063\uff4d\001\002\000" +
    "\012\023\uff4c\024\uff4c\055\uff4c\063\uff4c\001\002\000\032" +
    "\005\231\006\244\026\252\031\270\032\260\045\245\055" +
    "\uff58\060\271\061\241\063\uff58\065\010\072\254\001\002" +
    "\000\006\055\u0135\063\021\001\002\000\032\011\310\013" +
    "\073\015\044\037\313\065\010\066\307\072\334\077\327" +
    "\101\312\107\331\117\311\120\324\001\002\000\012\023" +
    "\uff52\024\uff52\055\uff52\063\uff52\001\002\000\004\040\uff31" +
    "\001\002\000\004\040\u0139\001\002\000\016\013\073\015" +
    "\044\065\010\066\050\072\105\107\077\001\002\000\006" +
    "\070\u0142\071\015\001\002\000\006\024\u013f\063\u013d\001" +
    "\002\000\006\024\uff2f\063\uff2f\001\002\000\020\013\ufef5" +
    "\015\ufef5\024\u0141\065\ufef5\066\ufef5\072\ufef5\107\ufef5\001" +
    "\002\000\016\013\073\015\044\065\010\066\050\072\105" +
    "\107\077\001\002\000\012\023\uff33\024\uff33\055\uff33\063" +
    "\uff33\001\002\000\006\024\uff30\063\uff30\001\002\000\012" +
    "\023\uff32\024\uff32\055\uff32\063\uff32\001\002\000\032\005" +
    "\231\006\244\024\uff58\026\252\031\270\032\260\045\245" +
    "\060\271\061\241\063\uff58\065\010\072\254\001\002\000" +
    "\006\024\uff2e\063\uff2e\001\002\000\006\021\u0148\071\015" +
    "\001\002\000\014\021\uff27\064\u0110\071\uff27\077\u010e\112" +
    "\u010f\001\002\000\014\021\uff45\064\uff45\071\uff45\077\uff45" +
    "\112\uff45\001\002\000\004\065\010\001\002\000\036\005" +
    "\231\006\244\023\uff58\024\uff58\026\252\031\270\032\260" +
    "\045\245\055\uff58\060\271\061\241\063\uff58\065\010\072" +
    "\254\001\002\000\010\024\uff4b\055\uff4b\063\uff4b\001\002" +
    "\000\012\023\uff4a\024\uff4a\055\uff4a\063\uff4a\001\002\000" +
    "\014\021\uff28\064\u0110\071\uff28\077\u010e\112\u010f\001\002" +
    "\000\010\063\uff6e\070\u014d\101\uff6e\001\002\000\046\004" +
    "\101\013\073\015\044\041\055\044\072\046\070\050\065" +
    "\065\056\066\050\072\105\101\061\105\066\107\077\112" +
    "\063\113\075\114\064\115\100\116\051\001\002\000\006" +
    "\063\uff6f\110\uff6f\001\002\000\006\063\uff72\110\uff72\001" +
    "\002\000\004\101\u0152\001\002\000\006\063\uff85\110\uff85" +
    "\001\002\000\012\030\223\042\216\057\u0158\065\014\001" +
    "\002\000\006\063\uff7d\110\uff7d\001\002\000\004\101\uff71" +
    "\001\002\000\006\063\uff78\110\uff78\001\002\000\006\063" +
    "\uff7f\110\uff7f\001\002\000\006\063\uff79\110\uff79\001\002" +
    "\000\004\065\014\001\002\000\006\063\021\110\u0160\001" +
    "\002\000\006\063\uff7c\110\uff7c\001\002\000\006\070\u015e" +
    "\071\015\001\002\000\006\063\uff80\110\uff80\001\002\000" +
    "\006\063\uff7e\110\uff7e\001\002\000\046\004\101\013\073" +
    "\015\044\041\055\044\072\046\070\050\065\065\056\066" +
    "\050\072\105\101\061\105\066\107\077\112\063\113\075" +
    "\114\064\115\100\116\051\001\002\000\006\063\uff7b\110" +
    "\uff7b\001\002\000\010\063\uff82\070\uff82\110\uff82\001\002" +
    "\000\012\030\223\042\216\057\u0158\065\014\001\002\000" +
    "\006\063\uff81\110\uff81\001\002\000\006\070\u0164\071\015" +
    "\001\002\000\046\004\101\013\073\015\044\041\055\044" +
    "\072\046\070\050\065\065\056\066\050\072\105\101\061" +
    "\105\066\107\077\112\063\113\075\114\064\115\100\116" +
    "\051\001\002\000\006\063\uff7a\110\uff7a\001\002\000\004" +
    "\101\u0152\001\002\000\004\070\u0168\001\002\000\046\004" +
    "\101\013\073\015\044\041\055\044\072\046\070\050\065" +
    "\065\056\066\050\072\105\101\061\105\066\107\077\112" +
    "\063\113\075\114\064\115\100\116\051\001\002\000\006" +
    "\063\uff70\110\uff70\001\002\000\026\003\023\005\ufff4\007" +
    "\ufff4\027\u016b\030\ufff4\036\024\042\ufff4\047\u016c\053\ufff4" +
    "\057\ufff4\001\002\000\004\063\uff84\001\002\000\004\063" +
    "\uff83\001\002\000\004\063\uff88\001\002\000\004\063\uff76" +
    "\001\002\000\004\063\uff89\001\002\000\010\063\uff77\101" +
    "\uff77\110\uff77\001\002\000\026\003\023\005\ufff4\007\ufff4" +
    "\027\u016b\030\ufff4\036\024\042\ufff4\047\u016c\053\ufff4\057" +
    "\ufff4\001\002\000\004\063\uff73\001\002\000\004\063\uff6d" +
    "\001\002\000\004\063\uff75\001\002\000\022\003\023\005" +
    "\ufff4\007\ufff4\030\ufff4\036\024\042\ufff4\053\ufff4\057\ufff4" +
    "\001\002\000\004\063\uff74\001\002\000\014\003\u0178\005" +
    "\uff96\030\uff96\042\uff96\065\014\001\002\000\004\063\uff91" +
    "\001\002\000\006\070\u017b\071\015\001\002\000\014\003" +
    "\uff93\005\uff93\030\uff93\042\uff93\065\uff93\001\002\000\046" +
    "\004\101\013\073\015\044\041\055\044\072\046\070\050" +
    "\065\065\056\066\050\072\105\101\061\105\066\107\077" +
    "\112\063\113\075\114\064\115\100\116\051\001\002\000" +
    "\004\063\021\001\002\000\014\003\uff92\005\uff92\030\uff92" +
    "\042\uff92\065\uff92\001\002\000\004\063\021\001\002\000" +
    "\014\003\uff90\005\uff90\030\uff90\042\uff90\065\uff90\001\002" +
    "\000\014\003\uff94\005\uff94\030\uff94\042\uff94\065\uff94\001" +
    "\002\000\004\063\uffeb\001\002\000\004\074\u0186\001\002" +
    "\000\020\003\uffed\005\uffed\030\uffed\042\uffed\053\uffed\057" +
    "\uffed\065\uffed\001\002\000\020\003\u0181\005\ufff0\030\ufff0" +
    "\042\ufff0\053\ufff0\057\ufff0\065\010\001\002\000\020\003" +
    "\uffee\005\uffee\030\uffee\042\uffee\053\uffee\057\uffee\065\uffee" +
    "\001\002\000\024\011\u018a\013\073\015\044\037\313\065" +
    "\010\066\307\072\334\101\u018c\107\331\001\002\000\032" +
    "\012\365\013\352\015\357\034\354\063\uffe9\074\356\075" +
    "\355\076\361\100\360\102\364\103\353\110\uffe9\001\002" +
    "\000\046\010\uffe1\012\uffe1\013\uffe1\014\uffe1\015\uffe1\016" +
    "\uffe1\017\uffe1\020\uffe1\034\uffe1\063\uffe1\074\uffe1\075\uffe1" +
    "\076\uffe1\100\uffe1\102\uffe1\103\uffe1\110\uffe1\111\u0199\001" +
    "\002\000\046\010\uffdf\012\uffdf\013\uffdf\014\uffdf\015\uffdf" +
    "\016\uffdf\017\uffdf\020\uffdf\034\uffdf\063\uffdf\074\uffdf\075" +
    "\uffdf\076\uffdf\100\uffdf\102\uffdf\103\uffdf\110\uffdf\111\uffdf" +
    "\001\002\000\020\011\u018a\037\313\065\010\066\307\072" +
    "\334\101\u018c\107\331\001\002\000\044\010\uffe2\012\uffe2" +
    "\013\uffe2\014\uffe2\015\uffe2\016\uffe2\017\uffe2\020\uffe2\034" +
    "\uffe2\063\uffe2\074\uffe2\075\uffe2\076\uffe2\100\uffe2\102\uffe2" +
    "\103\uffe2\110\uffe2\001\002\000\024\011\u018a\013\073\015" +
    "\044\037\313\065\010\066\307\072\334\101\u018c\107\331" +
    "\001\002\000\046\010\uffdd\012\uffdd\013\uffdd\014\uffdd\015" +
    "\uffdd\016\uffdd\017\uffdd\020\uffdd\034\uffdd\063\uffdd\074\uffdd" +
    "\075\uffdd\076\uffdd\100\uffdd\102\uffdd\103\uffdd\110\uffdd\111" +
    "\uffdd\001\002\000\004\063\021\001\002\000\044\010\uffe5" +
    "\012\uffe5\013\uffe5\014\uffe5\015\uffe5\016\uffe5\017\uffe5\020" +
    "\uffe5\034\uffe5\063\uffe5\074\uffe5\075\uffe5\076\uffe5\100\uffe5" +
    "\102\uffe5\103\uffe5\110\uffe5\001\002\000\044\010\372\012" +
    "\uffe7\013\uffe7\014\367\015\uffe7\016\374\017\370\020\373" +
    "\034\uffe7\063\uffe7\074\uffe7\075\uffe7\076\uffe7\100\uffe7\102" +
    "\uffe7\103\uffe7\110\uffe7\001\002\000\024\011\u018a\013\073" +
    "\015\044\037\313\065\010\066\307\072\334\101\u018c\107" +
    "\331\001\002\000\044\010\uffe3\012\uffe3\013\uffe3\014\uffe3" +
    "\015\uffe3\016\uffe3\017\uffe3\020\uffe3\034\uffe3\063\uffe3\074" +
    "\uffe3\075\uffe3\076\uffe3\100\uffe3\102\uffe3\103\uffe3\110\uffe3" +
    "\001\002\000\024\011\u018a\013\073\015\044\037\313\065" +
    "\010\066\307\072\334\101\u018c\107\331\001\002\000\044" +
    "\010\uffe4\012\uffe4\013\uffe4\014\uffe4\015\uffe4\016\uffe4\017" +
    "\uffe4\020\uffe4\034\uffe4\063\uffe4\074\uffe4\075\uffe4\076\uffe4" +
    "\100\uffe4\102\uffe4\103\uffe4\110\uffe4\001\002\000\020\003" +
    "\uffec\005\uffec\030\uffec\042\uffec\053\uffec\057\uffec\065\uffec" +
    "\001\002\000\004\110\u0197\001\002\000\046\010\uffde\012" +
    "\uffde\013\uffde\014\uffde\015\uffde\016\uffde\017\uffde\020\uffde" +
    "\034\uffde\063\uffde\074\uffde\075\uffde\076\uffde\100\uffde\102" +
    "\uffde\103\uffde\110\uffde\111\uffde\001\002\000\046\010\uffdc" +
    "\012\uffdc\013\uffdc\014\uffdc\015\uffdc\016\uffdc\017\uffdc\020" +
    "\uffdc\034\uffdc\063\uffdc\074\uffdc\075\uffdc\076\uffdc\100\uffdc" +
    "\102\uffdc\103\uffdc\110\uffdc\111\uffdc\001\002\000\020\011" +
    "\u018a\037\313\065\010\066\307\072\334\101\u018c\107\331" +
    "\001\002\000\044\010\uffe0\012\uffe0\013\uffe0\014\uffe0\015" +
    "\uffe0\016\uffe0\017\uffe0\020\uffe0\034\uffe0\063\uffe0\074\uffe0" +
    "\075\uffe0\076\uffe0\100\uffe0\102\uffe0\103\uffe0\110\uffe0\001" +
    "\002\000\024\011\u018a\013\073\015\044\037\313\065\010" +
    "\066\307\072\334\101\u018c\107\331\001\002\000\024\011" +
    "\u018a\013\073\015\044\037\313\065\010\066\307\072\334" +
    "\101\u018c\107\331\001\002\000\044\010\372\012\uffe6\013" +
    "\uffe6\014\367\015\uffe6\016\374\017\370\020\373\034\uffe6" +
    "\063\uffe6\074\uffe6\075\uffe6\076\uffe6\100\uffe6\102\uffe6\103" +
    "\uffe6\110\uffe6\001\002\000\014\012\365\013\352\015\357" +
    "\063\uffe8\110\uffe8\001\002\000\004\063\021\001\002\000" +
    "\020\003\uffea\005\uffea\030\uffea\042\uffea\053\uffea\057\uffea" +
    "\065\uffea\001\002\000\006\063\ufff2\071\ufff2\001\002\000" +
    "\006\063\021\071\015\001\002\000\004\072\254\001\002" +
    "\000\016\005\ufff7\007\ufff7\030\ufff7\042\ufff7\053\ufff7\057" +
    "\ufff7\001\002\000\006\063\ufff3\071\ufff3\001\002\000\004" +
    "\063\021\001\002\000\016\005\ufff5\007\ufff5\030\ufff5\042" +
    "\ufff5\053\ufff5\057\ufff5\001\002\000\004\002\000\001\002" +
    "" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\u01a6\000\006\002\003\003\004\001\001\000\002\001" +
    "\001\000\004\206\021\001\001\000\004\202\006\001\001" +
    "\000\004\210\010\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\004\012\001\001\000\004\207\015\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\007\025\011\024\001\001\000\004\212\u01a5\001\001\000" +
    "\006\012\u01a1\013\u01a0\001\001\000\004\014\030\001\001" +
    "\000\002\001\001\000\002\001\001\000\010\015\u0183\016" +
    "\u0182\202\u0181\001\001\000\004\027\031\001\001\000\004" +
    "\067\211\001\001\000\010\030\036\031\034\202\033\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\214\040" +
    "\001\001\000\006\031\037\202\033\001\001\000\002\001" +
    "\001\000\004\206\041\001\001\000\002\001\001\000\042" +
    "\025\045\026\051\032\073\034\057\035\070\036\053\037" +
    "\066\040\056\041\102\042\075\047\061\062\103\064\046" +
    "\065\052\202\044\205\101\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\014\041\205\042\075\047\061" +
    "\062\103\064\046\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\004\203\001\001\000\002" +
    "\001\001\000\006\066\202\202\201\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\004\125\050" +
    "\126\051\124\052\123\001\001\000\002\001\001\000\004" +
    "\206\122\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\026\105\202\044\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\026\025\045" +
    "\026\051\035\113\036\053\037\066\043\111\044\112\045" +
    "\107\202\110\205\101\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\207\114\001\001\000\002\001\001\000" +
    "\002\001\001\000\024\025\045\026\051\035\113\036\053" +
    "\037\066\044\121\045\107\202\110\205\101\001\001\000" +
    "\002\001\001\000\044\025\045\026\051\032\117\034\057" +
    "\035\070\036\053\037\066\040\056\041\102\042\075\046" +
    "\120\047\061\062\103\064\046\065\052\202\044\205\101" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\207\015\001\001\000\004\206\165\001\001\000" +
    "\012\053\132\060\131\061\130\202\133\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\022\025\140\026\051\054\137\055\136\056\135" +
    "\057\141\202\044\205\101\001\001\000\004\207\146\001" +
    "\001\000\002\001\001\000\004\206\144\001\001\000\002" +
    "\001\001\000\002\001\001\000\012\025\143\026\051\202" +
    "\044\205\101\001\001\000\002\001\001\000\020\025\140" +
    "\026\051\055\145\056\135\057\141\202\044\205\101\001" +
    "\001\000\002\001\001\000\014\025\140\026\051\057\161" +
    "\202\044\205\101\001\001\000\002\001\001\000\012\004" +
    "\125\050\152\051\124\052\151\001\001\000\002\001\001" +
    "\000\004\206\154\001\001\000\002\001\001\000\010\004" +
    "\125\051\156\052\155\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\061\163\202\164\001\001\000\002\001\001" +
    "\000\002\001\001\000\010\004\125\051\156\052\167\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\042\025\045\026\051\032\172\034\057\035\070\036" +
    "\053\037\066\040\056\041\102\042\075\047\061\062\103" +
    "\064\046\065\052\202\044\205\101\001\001\000\002\001" +
    "\001\000\002\001\001\000\024\025\045\026\051\035\113" +
    "\036\053\037\066\045\175\063\176\202\110\205\101\001" +
    "\001\000\002\001\001\000\002\001\001\000\044\025\045" +
    "\026\051\032\117\034\057\035\070\036\053\037\066\040" +
    "\056\041\102\042\075\046\200\047\061\062\103\064\046" +
    "\065\052\202\044\205\101\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\004\207\015\001\001" +
    "\000\002\001\001\000\002\001\001\000\012\025\207\026" +
    "\051\202\044\205\101\001\001\000\002\001\001\000\010" +
    "\004\u0178\070\u0176\071\u0179\001\001\000\024\072\223\073" +
    "\224\074\220\075\221\076\216\107\217\110\212\113\213" +
    "\114\214\001\001\000\006\206\u0174\217\u0165\001\001\000" +
    "\002\001\001\000\004\206\u0170\001\001\000\004\202\u016f" +
    "\001\001\000\004\206\u0169\001\001\000\004\216\u014f\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\202\u014b" +
    "\001\001\000\004\211\227\001\001\000\004\206\225\001" +
    "\001\000\020\074\226\075\221\076\216\107\217\110\212" +
    "\113\213\114\214\001\001\000\002\001\001\000\006\116" +
    "\232\117\231\001\001\000\070\005\245\006\247\013\271" +
    "\117\246\120\275\121\262\122\241\123\236\124\263\125" +
    "\266\126\273\127\252\130\274\131\272\132\255\133\235" +
    "\134\250\135\233\136\237\137\256\140\260\141\264\144" +
    "\234\145\265\151\242\152\261\202\254\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\014\140\u0144\141\264\144\234\161\u0143\202\u0145\001" +
    "\001\000\002\001\001\000\002\001\001\000\046\140\304" +
    "\141\264\144\234\153\u0137\163\u0136\164\322\165\317\166" +
    "\316\167\313\170\324\171\321\172\325\173\315\174\334" +
    "\175\327\176\320\202\305\205\332\001\001\000\004\220" +
    "\u0132\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\006\156\u0123\202\u0122\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\146\u0121" +
    "\001\001\000\002\001\001\000\002\001\001\000\046\140" +
    "\304\141\264\144\234\162\u011a\163\314\164\322\165\317" +
    "\166\316\167\313\170\324\171\321\172\325\173\315\174" +
    "\334\175\327\176\320\202\305\205\332\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\013\u0117\001\001\000\046\140\304\141\264\144" +
    "\234\162\331\163\314\164\322\165\317\166\316\167\313" +
    "\170\324\171\321\172\325\173\315\174\334\175\327\176" +
    "\320\202\305\205\332\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\206" +
    "\276\001\001\000\066\005\245\006\247\013\271\117\246" +
    "\121\300\122\241\123\236\124\263\125\266\126\273\127" +
    "\252\130\274\131\272\132\255\133\235\134\250\135\233" +
    "\136\237\137\256\140\260\141\264\144\234\145\265\151" +
    "\242\152\261\202\254\001\001\000\002\001\001\000\002" +
    "\001\001\000\056\005\245\006\247\117\246\124\302\125" +
    "\303\126\273\127\252\130\274\131\272\132\255\133\235" +
    "\134\250\135\233\136\237\137\256\140\260\141\264\144" +
    "\234\145\265\151\242\152\261\202\254\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\146" +
    "\u0102\001\001\000\002\001\001\000\030\140\304\141\264" +
    "\144\234\170\u0100\171\321\172\325\173\315\174\334\175" +
    "\327\176\320\202\305\001\001\000\002\001\001\000\044" +
    "\140\304\141\264\144\234\163\376\164\322\165\317\166" +
    "\316\167\313\170\324\171\321\172\325\173\315\174\334" +
    "\175\327\176\320\202\305\205\332\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\204\370\001\001\000\002\001" +
    "\001\000\002\001\001\000\006\201\361\203\362\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\050\140\304\141\264\144\234\163\340\164\322\165\317" +
    "\166\316\167\313\170\324\171\321\172\325\173\315\174" +
    "\334\175\327\176\320\177\341\200\336\202\305\205\332" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\036\140\304\141\264\144\234\166\335\167\313" +
    "\170\324\171\321\172\325\173\315\174\334\175\327\176" +
    "\320\202\305\205\332\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\207\342\001\001\000\046" +
    "\140\304\141\264\144\234\163\340\164\322\165\317\166" +
    "\316\167\313\170\324\171\321\172\325\173\315\174\334" +
    "\175\327\176\320\200\344\202\305\205\332\001\001\000" +
    "\002\001\001\000\002\001\001\000\044\140\304\141\264" +
    "\144\234\163\346\164\322\165\317\166\316\167\313\170" +
    "\324\171\321\172\325\173\315\174\334\175\327\176\320" +
    "\202\305\205\332\001\001\000\002\001\001\000\032\140" +
    "\304\141\264\144\234\167\350\170\324\171\321\172\325" +
    "\173\315\174\334\175\327\176\320\202\305\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\042\140\304" +
    "\141\264\144\234\164\375\165\317\166\316\167\313\170" +
    "\324\171\321\172\325\173\315\174\334\175\327\176\320" +
    "\202\305\205\332\001\001\000\040\140\304\141\264\144" +
    "\234\165\365\166\316\167\313\170\324\171\321\172\325" +
    "\173\315\174\334\175\327\176\320\202\305\205\332\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\204\370" +
    "\001\001\000\002\001\001\000\002\001\001\000\036\140" +
    "\304\141\264\144\234\166\374\167\313\170\324\171\321" +
    "\172\325\173\315\174\334\175\327\176\320\202\305\205" +
    "\332\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\203\362\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\050" +
    "\140\304\141\264\144\234\147\u0105\150\u0103\163\u0104\164" +
    "\322\165\317\166\316\167\313\170\324\171\321\172\325" +
    "\173\315\174\334\175\327\176\320\202\305\205\332\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\004\207\u0106\001\001\000\046\140\304\141\264\144" +
    "\234\150\u0108\163\u0104\164\322\165\317\166\316\167\313" +
    "\170\324\171\321\172\325\173\315\174\334\175\327\176" +
    "\320\202\305\205\332\001\001\000\002\001\001\000\002" +
    "\001\001\000\044\140\304\141\264\144\234\163\u010a\164" +
    "\322\165\317\166\316\167\313\170\324\171\321\172\325" +
    "\173\315\174\334\175\327\176\320\202\305\205\332\001" +
    "\001\000\002\001\001\000\044\140\304\141\264\144\234" +
    "\163\u010c\164\322\165\317\166\316\167\313\170\324\171" +
    "\321\172\325\173\315\174\334\175\327\176\320\202\305" +
    "\205\332\001\001\000\002\001\001\000\050\140\304\141" +
    "\264\142\u0111\143\u0113\144\234\163\u0112\164\322\165\317" +
    "\166\316\167\313\170\324\171\321\172\325\173\315\174" +
    "\334\175\327\176\320\202\305\205\332\001\001\000\002" +
    "\001\001\000\004\202\u0110\001\001\000\002\001\001\000" +
    "\004\207\u0114\001\001\000\002\001\001\000\002\001\001" +
    "\000\046\140\304\141\264\143\u0116\144\234\163\u0112\164" +
    "\322\165\317\166\316\167\313\170\324\171\321\172\325" +
    "\173\315\174\334\175\327\176\320\202\305\205\332\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\044\140\304\141\264\144\234\163\u0119\164\322\165" +
    "\317\166\316\167\313\170\324\171\321\172\325\173\315" +
    "\174\334\175\327\176\320\202\305\205\332\001\001\000" +
    "\002\001\001\000\002\001\001\000\066\005\245\006\247" +
    "\013\271\117\246\121\u011d\122\241\123\u011c\124\263\125" +
    "\266\126\273\127\252\130\274\131\272\132\255\133\235" +
    "\134\250\135\233\136\237\137\256\140\260\141\264\144" +
    "\234\145\265\151\242\152\261\202\254\001\001\000\002" +
    "\001\001\000\002\001\001\000\064\005\245\006\247\013" +
    "\271\117\246\122\u011f\123\u0120\124\263\125\266\126\273" +
    "\127\252\130\274\131\272\132\255\133\235\134\250\135" +
    "\233\136\237\137\256\140\260\141\264\144\234\145\265" +
    "\151\242\152\261\202\254\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\046\140\304\141\264\144\234\157\u0126\163" +
    "\u0125\164\322\165\317\166\316\167\313\170\324\171\321" +
    "\172\325\173\315\174\334\175\327\176\320\202\305\205" +
    "\332\001\001\000\002\001\001\000\004\111\u0128\001\001" +
    "\000\002\001\001\000\046\140\304\141\264\144\234\160" +
    "\u012b\163\u012a\164\322\165\317\166\316\167\313\170\324" +
    "\171\321\172\325\173\315\174\334\175\327\176\320\202" +
    "\305\205\332\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\064\005\245\006\247\013\271\117" +
    "\246\122\u012d\123\u012e\124\263\125\266\126\273\127\252" +
    "\130\274\131\272\132\255\133\235\134\250\135\233\136" +
    "\237\137\256\140\260\141\264\144\234\145\265\151\242" +
    "\152\261\202\254\001\001\000\002\001\001\000\002\001" +
    "\001\000\064\005\245\006\247\013\271\117\246\122\u0130" +
    "\123\u0131\124\263\125\266\126\273\127\252\130\274\131" +
    "\272\132\255\133\235\134\250\135\233\136\237\137\256" +
    "\140\260\141\264\144\234\145\265\151\242\152\261\202" +
    "\254\001\001\000\002\001\001\000\002\001\001\000\070" +
    "\005\245\006\247\013\271\117\246\120\u0133\121\262\122" +
    "\241\123\236\124\263\125\266\126\273\127\252\130\274" +
    "\131\272\132\255\133\235\134\250\135\233\136\237\137" +
    "\256\140\260\141\264\144\234\145\265\151\242\152\261" +
    "\202\254\001\001\000\004\206\276\001\001\000\046\140" +
    "\304\141\264\144\234\162\u0135\163\314\164\322\165\317" +
    "\166\316\167\313\170\324\171\321\172\325\173\315\174" +
    "\334\175\327\176\320\202\305\205\332\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\022\025" +
    "\140\026\051\056\u0139\057\141\154\u013a\155\u013b\202\044" +
    "\205\101\001\001\000\004\207\146\001\001\000\004\206" +
    "\u013d\001\001\000\002\001\001\000\002\001\001\000\020" +
    "\025\140\026\051\056\u0139\057\141\155\u013f\202\044\205" +
    "\101\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\066\005\245\006\247\013\271\117\246\121" +
    "\u0142\122\241\123\236\124\263\125\266\126\273\127\252" +
    "\130\274\131\272\132\255\133\235\134\250\135\233\136" +
    "\237\137\256\140\260\141\264\144\234\145\265\151\242" +
    "\152\261\202\254\001\001\000\002\001\001\000\004\207" +
    "\u0146\001\001\000\002\001\001\000\002\001\001\000\012" +
    "\140\u014a\141\264\144\234\202\u0145\001\001\000\064\005" +
    "\245\006\247\013\271\117\246\122\u0148\123\u0149\124\263" +
    "\125\266\126\273\127\252\130\274\131\272\132\255\133" +
    "\235\134\250\135\233\136\237\137\256\140\260\141\264" +
    "\144\234\145\265\151\242\152\261\202\254\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\044\025\045\026\051\032\u014d\033\u014e\034" +
    "\057\035\070\036\053\037\066\040\056\041\102\042\075" +
    "\047\061\062\103\064\046\065\052\202\044\205\101\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\100\u0150" +
    "\001\001\000\002\001\001\000\030\004\u015a\076\u0156\101" +
    "\u0158\102\u015b\103\u0155\104\u015c\105\u0152\106\u0159\107\217" +
    "\110\u0153\114\u0154\001\001\000\002\001\001\000\004\217" +
    "\u0165\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\004\u0162\001\001\000\004\206\u0160\001" +
    "\001\000\002\001\001\000\004\207\015\001\001\000\002" +
    "\001\001\000\002\001\001\000\042\025\045\026\051\032" +
    "\u015e\034\057\035\070\036\053\037\066\040\056\041\102" +
    "\042\075\047\061\062\103\064\046\065\052\202\044\205" +
    "\101\001\001\000\002\001\001\000\002\001\001\000\026" +
    "\004\u015a\076\u0156\102\u0161\103\u0155\104\u015c\105\u0152\106" +
    "\u0159\107\217\110\u0153\114\u0154\001\001\000\002\001\001" +
    "\000\004\207\015\001\001\000\042\025\045\026\051\032" +
    "\u0164\034\057\035\070\036\053\037\066\040\056\041\102" +
    "\042\075\047\061\062\103\064\046\065\052\202\044\205" +
    "\101\001\001\000\002\001\001\000\004\100\u0166\001\001" +
    "\000\002\001\001\000\044\025\045\026\051\032\u014d\033" +
    "\u0168\034\057\035\070\036\053\037\066\040\056\041\102" +
    "\042\075\047\061\062\103\064\046\065\052\202\044\205" +
    "\101\001\001\000\002\001\001\000\012\007\u016d\011\024" +
    "\077\u016e\112\u016c\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\012\007\u0172\011\024\077\u0173\115" +
    "\u0171\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\010\007\u0172\011\024\115\u0175\001\001\000" +
    "\002\001\001\000\006\004\u0178\071\u017f\001\001\000\004" +
    "\215\u017d\001\001\000\004\207\015\001\001\000\002\001" +
    "\001\000\042\025\045\026\051\032\u017b\034\057\035\070" +
    "\036\053\037\066\040\056\041\102\042\075\047\061\062" +
    "\103\064\046\065\052\202\044\205\101\001\001\000\004" +
    "\206\u017c\001\001\000\002\001\001\000\004\206\u017e\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\213\u019e" +
    "\001\001\000\002\001\001\000\002\001\001\000\006\016" +
    "\u0184\202\u0181\001\001\000\002\001\001\000\032\017\u018d" +
    "\020\u0186\021\u018f\022\u018e\023\u018a\024\u0187\171\u018c\172" +
    "\325\173\315\174\334\202\u0188\205\u0190\001\001\000\006" +
    "\201\u019a\203\u019b\001\001\000\002\001\001\000\002\001" +
    "\001\000\016\024\u0197\171\u018c\172\325\173\315\174\334" +
    "\202\u0188\001\001\000\002\001\001\000\032\017\u0195\020" +
    "\u0186\021\u018f\022\u018e\023\u018a\024\u0187\171\u018c\172\325" +
    "\173\315\174\334\202\u0188\205\u0190\001\001\000\002\001" +
    "\001\000\004\206\u0194\001\001\000\002\001\001\000\004" +
    "\204\u0192\001\001\000\024\022\u0191\023\u018a\024\u0187\171" +
    "\u018c\172\325\173\315\174\334\202\u0188\205\u0190\001\001" +
    "\000\002\001\001\000\024\022\u0193\023\u018a\024\u0187\171" +
    "\u018c\172\325\173\315\174\334\202\u0188\205\u0190\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\020\023\u0199\024\u0187" +
    "\171\u018c\172\325\173\315\174\334\202\u0188\001\001\000" +
    "\002\001\001\000\030\020\u019d\021\u018f\022\u018e\023\u018a" +
    "\024\u0187\171\u018c\172\325\173\315\174\334\202\u0188\205" +
    "\u0190\001\001\000\026\021\u019c\022\u018e\023\u018a\024\u0187" +
    "\171\u018c\172\325\173\315\174\334\202\u0188\205\u0190\001" +
    "\001\000\004\204\u0192\001\001\000\004\203\u019b\001\001" +
    "\000\004\206\u019f\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\206\u01a3\207\u01a2\001\001\000\004\013\u01a4" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\206" +
    "\u01a6\001\001\000\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 1;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {

	TabelaDeSimbolos.inicializa();
	Tipo.criaTipos();

    }


    
    public static int errors = 0;
    public static StringBuffer code = new StringBuffer();
    
    public void report_error(String message, Object info) {
   
        
        StringBuilder m = new StringBuilder("Error");
   		errors++; 
          
        m.append(" : "+message);
   
        System.err.println("Error "+ Main.pascalLexer.current_lexeme() + " : Sintantic error");
        System.err.println(m + "" + (info instanceof String ? info : ""));
        
    }
   
    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
    
    public void sem_error(String lexeme, String message) {
		errors ++;
		System.err.println("Error in line "+ Main.pascalLexer.current_line() + " : Semantic error");
      	System.err.println("==> " + message + ": "+ lexeme + "\n");
  	}
  	
  	public void sem_error(String message) {
		errors ++;
		System.err.println("Error "+ Main.pascalLexer.current_lexeme() + " : Semantic error");
      	System.err.println("==> " + message +"\n");
  	}
  	
    

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	
	class Exp {
	  public Tipo tipo;
	  public String code;
	  public boolean isConstant;

	  Exp(Tipo t, String code) {
		this(t, code, false);
	  }
	  
	  Exp(Tipo t, String code, boolean cte) {
		tipo = t;
		this.code = code;
		isConstant = cte;
	  }

	}
	
	class Reg {
		
		 
		public String id;
		public String val;
		
		Reg(String id) {
			this(id,"");
		}
		
		Reg(String id, String val) {
			this.id = id;
			this.val = val;
		}
	
	}
	
	public static String assembOp(String pascOper) {
		if(pascOper.equals("-")) {
			return "SUB";
		}
		else if(pascOper.equals("+")) {
			return "ADD";
		}
		else if(pascOper.equals("*")) {
			return "MUL";
		}
		else if(pascOper.equals("/") || pascOper.toLowerCase().equals("div")) {
			return "DIV";
		}
		return "";
	}
	
	/* listas auxiliares para gerenciar registradores */
	List<Reg> argRegs = new ArrayList<Reg> ();
	
	/* pesquisa um registrador argumento dado seu valor */
	public Reg getArgReg(String val) {
		for(Reg reg : argRegs) {
			if(reg.val.equals(val))
				return reg;
		}
		return null;
	}
	
	/* lista para gerenciar destino de laos (labels) */
	List<Integer> labels = new ArrayList<Integer>();
	
	/* variavel auxiliar para manipulacao de labels */
	int label = 0;
	

  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 269: // comma ::= COMMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("comma",133, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 268: // semicolon ::= SEMICOLON 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("semicolon",132, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 267: // identifier ::= IDENTIFIER 
            {
              String RESULT =null;
		int xleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int xright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String x = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   								
   								RESULT = x; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("identifier",128, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 266: // relop ::= IN 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",127, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 265: // relop ::= GE 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",127, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 264: // relop ::= LE 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",127, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 263: // relop ::= GT 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",127, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 262: // relop ::= LT 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",127, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 261: // relop ::= NOTEQUAL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",127, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 260: // relop ::= EQUAL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("relop",127, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 259: // mulop ::= AND 
            {
              String RESULT =null;
		int aleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int aright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String a = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = a; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",130, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 258: // mulop ::= MOD 
            {
              String RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String m = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = m; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",130, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 257: // mulop ::= DIV 
            {
              String RESULT =null;
		int dleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String d = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = d; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",130, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 256: // mulop ::= SLASH 
            {
              String RESULT =null;
		int slleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int slright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String sl = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = sl; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",130, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 255: // mulop ::= STAR 
            {
              String RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String s = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = s; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("mulop",130, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 254: // addop ::= OR 
            {
              String RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String o = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = o; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("addop",129, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 253: // addop ::= MINUS 
            {
              String RESULT =null;
		int mleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String m = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = m; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("addop",129, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 252: // addop ::= PLUS 
            {
              String RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String p = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = p; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("addop",129, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 251: // member_designator ::= expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("member_designator",126, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 250: // member_designator ::= member_designator DOTDOT expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("member_designator",126, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 249: // member_designator_list ::= member_designator 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("member_designator_list",125, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 248: // member_designator_list ::= member_designator_list comma member_designator 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("member_designator_list",125, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 247: // set_constructor ::= LBRAC RBRAC 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("set_constructor",124, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 246: // set_constructor ::= LBRAC member_designator_list RBRAC 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("set_constructor",124, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 245: // function_designator ::= identifier params 
            {
              Exp RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int prsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int prsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<Exp> prs = (List<Exp>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   							Simbolo t = null;
   							if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   								parser.sem_error(id, "unknow name");
   								RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "?");
   							}
   							else {
								TipoFuncao tf = (TipoFuncao) t.getTipo();
   								if(tf.getTipoParametros().size() != prs.size()) {
   									parser.sem_error(id, "expected " + tf.getTipoParametros().size() + " parameters in function");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   								}
   								else {
   									for(int i = 0; i < prs.size(); i++) {
   										if(! tf.getTipoParametros().get(i).getVal().equals(prs.get(i).tipo.getVal())) {
   											parser.sem_error(id, "Tipos dos parametros passados sao imcompativeis com os parametros de");
   											RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   										} else {
											Reg argReg = argRegs.get(i);
											parser.code.append("\t LD "+argReg.id+" , "+prs.get(i).code +"\n"); 
   										}
   									}
   									parser.code.append("\t ADD SP , SP , #caller.recordSize\n"); 
   									parser.code.append("\t ST 0(SP) , #here + 16\n"); 
   									parser.code.append("\t BR "+id+"\n"); 
   									parser.code.append("\t SUB SP , SP , #caller.recordSize\n");
   									RESULT = new Exp(tf.getTipoRetorno(), "V0");
   								}
   							}
   						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_designator",123, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 244: // unsigned_real ::= REALNUMBER 
            {
              Exp RESULT =null;
		int rnleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rnright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object rn = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(Tipo.getTipo(Tipo.REAL), ""+rn); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unsigned_real",122, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 243: // unsigned_integer ::= DIGSEQ 
            {
              Exp RESULT =null;
		int dsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int dsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Object ds = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(Tipo.getTipo(Tipo.INTEGER), ""+ds); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unsigned_integer",121, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 242: // unsigned_number ::= unsigned_real 
            {
              Exp RESULT =null;
		int urleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int urright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp ur = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(ur.tipo, ur.code); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unsigned_number",120, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 241: // unsigned_number ::= unsigned_integer 
            {
              Exp RESULT =null;
		int uileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int uiright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp ui = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(ui.tipo, ui.code); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unsigned_number",120, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 240: // unsigned_constant ::= NIL 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("unsigned_constant",119, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 239: // unsigned_constant ::= CHARACTER_STRING 
            {
              Exp RESULT =null;
		int csleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int csright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String cs = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   						  RESULT = (cs.length() == 3) ? new Exp(Tipo.getTipo(Tipo.CHAR), cs) : 
														new Exp(Tipo.getTipo(Tipo.STRING), cs); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unsigned_constant",119, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 238: // unsigned_constant ::= unsigned_number 
            {
              Exp RESULT =null;
		int unleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int unright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp un = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(un.tipo, un.code); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("unsigned_constant",119, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 237: // primary ::= FALSE 
            {
              Exp RESULT =null;
		 RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), "0"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",118, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 236: // primary ::= TRUE 
            {
              Exp RESULT =null;
		 RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), "1"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",118, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 235: // primary ::= NOT primary 
            {
              Exp RESULT =null;
		int prleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int prright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp pr = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 if(! pr.tipo.getVal().equals("boolean")) {
             		if(! pr.tipo.getVal().equals("error")) {
             			parser.sem_error(pr.tipo.getVal(), "The operator NOT is undefined for the expression type");
             		}
             		RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
             	}
             	else {
					parser.code.append("\t LD R0 , "+pr.code+"\n");
					parser.code.append("\t NOT R0\n");
					pr.code = "R0";
             		RESULT = pr;
             	}
             
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",118, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 234: // primary ::= LPAREN expression RPAREN 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 
					if(getArgReg("temp") == null) {
						parser.code.append("\t LD R2 , "+exp.code+"\n");
						argRegs.add(new Reg("R2", "temp"));
						exp.code = "R2";
					}
					RESULT = exp; 
					
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",118, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 233: // primary ::= set_constructor 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",118, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 232: // primary ::= function_designator 
            {
              Exp RESULT =null;
		int fdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fdright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp fd = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(fd.tipo, fd.code); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",118, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 231: // primary ::= unsigned_constant 
            {
              Exp RESULT =null;
		int ucleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ucright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp uc = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(uc.tipo, "#"+uc.code, true); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",118, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 230: // primary ::= variable_access 
            {
              Exp RESULT =null;
		int valeft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int varight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp va = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   						if(va.tipo instanceof TipoFuncao) {
							TipoFuncao tf = (TipoFuncao) va.tipo;
   							if( tf.getTipoParametros().size() != 0) {
   								parser.sem_error("", "expected "+tf.getTipoParametros().size()
   											+" parameters in function");
								RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   							} else {
								parser.code.append("\t ADD SP , SP , #caller.recordSize\n"); 
   								parser.code.append("\t ST 0(SP) , #here + 16\n"); 
   								parser.code.append("\t BR "+va.code+"\n"); 
   								parser.code.append("\t SUB SP , SP , #caller.recordSize\n");
   								RESULT = new Exp(va.tipo,"V0");
   							}
   						} else {
							if(! TabelaDeSimbolos.escopoCorrente.isRoot()) {
									Reg arg = getArgReg(va.code);
									if(arg != null) {
										va.code = arg.id;
										//Se a variable_access for um argumento, carregar em regs diferentes
										parser.code.append("\t LD R"+va.code.charAt(1)+" , "+va.code +"\n"); 
										RESULT =  new Exp(va.tipo, "R"+va.code.charAt(1));
									}
									else {
										parser.code.append("\t LD R0 , "+va.code +"\n");
										RESULT =  new Exp(va.tipo, "R0"); 
									}
							}
							else {
								parser.code.append("\t LD R0 , "+va.code +"\n");
								RESULT =  new Exp(va.tipo, "R0"); 
							}
						}
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("primary",118, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 229: // exponentiation ::= primary STARSTAR exponentiation 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("exponentiation",117, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 228: // exponentiation ::= primary 
            {
              Exp RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp p = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
						RESULT = new Exp(p.tipo, p.code, p.isConstant); 
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exponentiation",117, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 227: // factor ::= exponentiation 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(exp.tipo, exp.code, exp.isConstant); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",116, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 226: // factor ::= sign factor 
            {
              Exp RESULT =null;
		int snleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int snright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String sn = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp f = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   				if(sn.toLowerCase().equals("-")) {
   					if(! (f.tipo.getVal().equals("integer") || f.tipo.getVal().equals("real"))) {
   						parser.sem_error(f.tipo.getVal(), "The operator - is undefined for the expression type");
   						RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   					}
   					else {
   						RESULT = f;
   					}
   				}
   				else if(sn.toLowerCase().equals("+")) {
   					if(! (f.tipo.getVal().equals("integer") || f.tipo.getVal().equals("real")
   							|| f.tipo.getVal().equals("string") || f.tipo.getVal().equals("char"))) {
   						parser.sem_error(f.tipo.getVal(), "The operator + is undefined for the expression type");
   						RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   					}
   					else {
   						RESULT = f;
   					}
   				}
   			
              CUP$parser$result = parser.getSymbolFactory().newSymbol("factor",116, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 225: // term ::= term mulop factor 
            {
              Exp RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp se = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int adleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int adright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String ad = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int teleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int teright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp te = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   						if(ad != null) {
   							if(ad.toLowerCase().equals("and")) {
   								if(!(se.tipo.getVal().equals("boolean") && te.tipo.getVal().equals("boolean"))) {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator AND is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   								}
   								else {
									if(! "R1".equals(se.code))
										parser.code.append("\t LD R1 , "+se.code+"\n");
									se.code = "R1";
									parser.code.append("\t AND "+se.code+" , "+se.code+" , "+te.code+"\n");
   									RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), se.code);
   								}
   							}
   							else if(ad.toLowerCase().equals("*") || ad.toLowerCase().equals("/")) {
   								if((se.tipo.getVal().equals("integer") || se.tipo.getVal().equals("real")) &&
   								  (te.tipo.getVal().equals("integer") || te.tipo.getVal().equals("real"))) {
   									String op = assembOp(ad.toLowerCase());
									if(se.isConstant) {
										parser.code.append("\t "+op+" R1 , "+se.code+" , "+te.code+"\n");
										se.code = "R1";
									}
									else {
										parser.code.append("\t "+op+" "+se.code+" , "+se.code+" , "+te.code+"\n");
									}
   									RESULT = new Exp(Tipo.maximo(se.tipo, te.tipo), se.code);
   								}
   								else {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator "+ad+" is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   								}
   							}
   							else if(ad.toLowerCase().equals("mod") || ad.toLowerCase().equals("div")) {
   								if(se.tipo.getVal().equals("integer") && te.tipo.getVal().equals("integer")) {
									String op = assembOp(ad.toLowerCase());
									if(se.isConstant) {
										parser.code.append("\t "+op+" R1 , "+se.code+" , "+te.code+"\n");
										se.code = "R1";
									}
									else {
										parser.code.append("\t "+op+" "+se.code+" , "+se.code+" , "+te.code+"\n");
									}
   									RESULT = new Exp(Tipo.getTipo(Tipo.INTEGER), se.code);
   								}
   								else {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator "+ad+" is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   								}
   							}
   						}
   					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("term",115, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 224: // term ::= factor 
            {
              Exp RESULT =null;
		int fleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp f = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(f.tipo, f.code, f.isConstant); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("term",115, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 223: // simple_expression ::= simple_expression addop term 
            {
              Exp RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int seright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp se = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int adleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int adright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String ad = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int teleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int teright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp te = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   						if(ad != null) {
   							if(ad.toLowerCase().equals("or")) {
   								if(!(se.tipo.getVal().equals("boolean") && te.tipo.getVal().equals("boolean"))) {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator OR is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   								}
   								else {
									if(! "R1".equals(se.code))
										parser.code.append("\t LD R1 , "+se.code+"\n");
									se.code = "R1";
									parser.code.append("\t OR "+se.code+" , "+se.code+" , "+te.code+"\n");
   									RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), se.code);
   								}
   							}
   							else if(ad.toLowerCase().equals("-") || ad.toLowerCase().equals("+")) {
   								if((se.tipo.getVal().equals("integer") || se.tipo.getVal().equals("real")) &&
   								  (te.tipo.getVal().equals("integer") || te.tipo.getVal().equals("real"))) {
									
									String op = assembOp(ad.toLowerCase());
									if(se.isConstant) {
										parser.code.append("\t "+op+" R1 , "+se.code+" , "+te.code+"\n");
										se.code = "R1";
									}
									else {
										parser.code.append("\t "+op+" "+se.code+" , "+se.code+" , "+te.code+"\n");
									}
   									RESULT = new Exp(Tipo.maximo(se.tipo, te.tipo), se.code);
   								}
   								else if((se.tipo.getVal().equals("char") || se.tipo.getVal().equals("string")) &&
   								  (te.tipo.getVal().equals("char") || te.tipo.getVal().equals("string"))) {
   									RESULT = new Exp(Tipo.maximo(se.tipo, te.tipo), "?");
   								}
   								else {
   									parser.sem_error(se.tipo.getVal() + ", " + te.tipo.getVal(), "The operator "+ad+" is undefined for the argument types ");
   									RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   								}
   							}
   							
   						}
   					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("simple_expression",114, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 222: // simple_expression ::= term 
            {
              Exp RESULT =null;
		int teleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int teright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp te = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
									RESULT = new Exp(te.tipo, te.code, te.isConstant); 
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("simple_expression",114, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 221: // expression ::= simple_expression relop simple_expression 
            {
              Exp RESULT =null;
		 RESULT = new Exp(Tipo.getTipo(Tipo.BOOLEAN), ""); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",113, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 220: // expression ::= simple_expression 
            {
              Exp RESULT =null;
		int seleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int seright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp se = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = new Exp(se.tipo, se.code); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expression",113, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 219: // boolean_expression ::= expression 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   							if(exp != null) {
   								if(! exp.tipo.getVal().equals("boolean")) {
   									if(! exp.tipo.getVal().equals("error"))
   										parser.sem_error(exp.tipo.getVal(), "cannot convert to boolean ");
   							 		RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   								}
   								else {
   									RESULT = new Exp(exp.tipo, exp.code);
   								}
   							}
   						  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("boolean_expression",112, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 218: // record_variable_list ::= variable_access 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_variable_list",111, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 217: // record_variable_list ::= record_variable_list comma variable_access 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_variable_list",111, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 216: // final_value ::= expression 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = exp; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("final_value",110, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 215: // direction ::= DOWNTO 
            {
              String RESULT =null;
		 RESULT = "downTo"; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("direction",71, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 214: // direction ::= TO 
            {
              String RESULT =null;
		 RESULT = "to"; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("direction",71, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 213: // initial_value ::= expression 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = exp; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("initial_value",109, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 212: // control_variable ::= identifier 
            {
              Exp RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   							Simbolo t = null;
   							if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   								parser.sem_error(id, "unknow name");
   								RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   							} else if(t.getTipo().getVal().equals("char") || t.getTipo().getVal().equals("integer")){
   								RESULT = new Exp(t.getTipo(), id); 
   							}
   							else {
   								parser.sem_error("char or integer", "The type of control variable '"+id+"' must be ");
   								RESULT = new Exp(Tipo.getTipo(Tipo.ERRO),"");
   							}
   						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("control_variable",108, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 211: // case_list_element ::= case_constant_list COLON statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("case_list_element",107, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 210: // case_list_element_list ::= case_list_element 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("case_list_element_list",106, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 209: // case_list_element_list ::= case_list_element_list semicolon case_list_element 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("case_list_element_list",106, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 208: // case_index ::= expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("case_index",105, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 207: // case_statement ::= CASE case_index OF case_list_element_list SEMICOLON END 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("case_statement",104, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 206: // case_statement ::= CASE case_index OF case_list_element_list END 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("case_statement",104, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 205: // goto_statement ::= GOTO label 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("goto_statement",103, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 204: // actual_parameter ::= expression COLON expression COLON expression 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("actual_parameter",102, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 203: // actual_parameter ::= expression COLON expression 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("actual_parameter",102, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 202: // actual_parameter ::= expression 
            {
              Exp RESULT =null;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp exp = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = exp; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("actual_parameter",102, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 201: // actual_parameter_list ::= actual_parameter 
            {
              List<Exp> RESULT =null;
		int apleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int apright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp ap = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   								List<Exp> l = new ArrayList<Exp>();
   								l.add(ap);
   								RESULT = l;
   							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("actual_parameter_list",101, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 200: // actual_parameter_list ::= actual_parameter_list comma actual_parameter 
            {
              List<Exp> RESULT =null;
		int aplleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int aplright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<Exp> apl = (List<Exp>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int apleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int apright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp ap = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   								apl.add(ap);
   								RESULT = apl;
   							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("actual_parameter_list",101, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 199: // params ::= LPAREN actual_parameter_list RPAREN 
            {
              List<Exp> RESULT =null;
		int aplleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int aplright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		List<Exp> apl = (List<Exp>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = apl; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("params",100, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 198: // procedure_statement ::= identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   							Simbolo t = null;
   							 if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   								 parser.sem_error(id, "unknow name");
   								
   							 }
   							 else {
   								
   								TipoFuncao tf = (TipoFuncao) t.getTipo();
   								if(tf.getTipoParametros().size() != 0) {
   									parser.sem_error(id, "expected " + tf.getTipoParametros().size() + " parameters in function");
   									
   								} else {
									parser.code.append("\t ADD SP , SP , #caller.recordSize\n"); 
   									parser.code.append("\t ST 0(SP) , #here + 16\n"); 
   									parser.code.append("\t BR "+id+"\n"); 
   									parser.code.append("\t SUB SP , SP , #caller.recordSize\n");
   								}
   							 }
   							
   						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_statement",99, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 197: // procedure_statement ::= identifier params 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int prsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int prsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<Exp> prs = (List<Exp>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   							
   							 Simbolo t = null;
   							 if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   								 parser.sem_error(id, "unknow name");
   								
   							 }
   							 else {
   								
   								TipoFuncao tf = (TipoFuncao) t.getTipo();
   								if(tf.getTipoParametros().size() != prs.size()) {
   									parser.sem_error(id, "expected " + tf.getTipoParametros().size() + " parameters in function");
   									
   								}
   								else {
   									for(int i = 0; i < prs.size(); i++) {
   										if(! tf.getTipoParametros().get(i).getVal().equals(prs.get(i).tipo.getVal())) {
   											parser.sem_error(id, "Tipos dos parametros passados sao imcompativeis com os parametros de");
   											
   										}
   										Reg argReg = new Reg("A"+i);
   										parser.code.append("\t LD "+argReg.id+" , "+prs.get(i).code+"\n"); 
   									}
   									parser.code.append("\t ADD SP , SP , #caller.recordSize\n"); 
   									parser.code.append("\t ST 0(SP) , #here + 16\n"); 
   									parser.code.append("\t BR "+id+"\n"); 
   									parser.code.append("\t SUB SP , SP , #caller.recordSize\n");
   								}
   							 }
   							
   						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_statement",99, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 196: // field_designator ::= variable_access DOT identifier 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("field_designator",98, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 195: // index_expression ::= expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("index_expression",97, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 194: // index_expression_list ::= index_expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("index_expression_list",96, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 193: // index_expression_list ::= index_expression_list comma index_expression 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("index_expression_list",96, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 192: // indexed_variable ::= variable_access LBRAC index_expression_list RBRAC 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("indexed_variable",95, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 191: // variable_access ::= variable_access UPARROW 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_access",94, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 190: // variable_access ::= field_designator 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_access",94, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 189: // variable_access ::= indexed_variable 
            {
              Exp RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_access",94, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 188: // variable_access ::= identifier 
            {
              Exp RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   					Simbolo t = null;
   					if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   						parser.sem_error(id, "unknow name");
   						RESULT = new Exp(Tipo.getTipo(Tipo.ERRO), "");
   					} else {
   						RESULT = new Exp(t.getTipo(), id); 
   					}
   					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_access",94, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 187: // assignment_statement ::= variable_access ASSIGNMENT expression 
            {
              Tipo RESULT =null;
		int tvaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tvaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp tva = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int texpleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int texpright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp texp = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   							if( tva.tipo instanceof TipoFuncao ) {
								if(TabelaDeSimbolos.escopoCorrente.isRoot()) {
									parser.sem_error(tva.code, "retorno fora do escopo da funcao ");
									RESULT = Tipo.getTipo(Tipo.ERRO);
								}
								else {
								    TipoFuncao tf = (TipoFuncao) tva.tipo;
								    Tipo rt = tf.getTipoRetorno();
								    if(! rt.getVal().equals(texp.tipo.getVal())) {
									 if(! rt.getVal().equals("error") && ! rt.getVal().equals("error")) {
										 if(! (rt.getVal().equals("real") && texp.tipo.getVal().equals("integer"))) {
											 parser.sem_error(rt.getVal(), "cannot convert from "+ texp.tipo.getVal() + " to ");
											 RESULT = Tipo.getTipo(Tipo.ERRO);
										 }
									 }
									}
									else {
										tva.code = "V0";
										parser.code.append("\t LD "+tva.code+" , "+texp.code +"\n");
										RESULT = Tipo.getTipo(Tipo.TIPO_VOID);
									}
								}
							}
   							else if(! tva.tipo.getVal().equals(texp.tipo.getVal())) {
   								if(! texp.tipo.getVal().equals("error") && ! tva.tipo.getVal().equals("error")) {
   									if(! (tva.tipo.getVal().equals("real") && texp.tipo.getVal().equals("integer"))) {
   										parser.sem_error(tva.tipo.getVal(), "cannot convert from "+ texp.tipo.getVal() + " to ");
   										RESULT = Tipo.getTipo(Tipo.ERRO);
   									}
   									else {
										parser.code.append("\t ST "+tva.code+" , "+texp.code +"\n");
   										RESULT = Tipo.getTipo(Tipo.TIPO_VOID);
   									}
   								}
   						   }
   						   else {
								parser.code.append("\t ST "+tva.code+" , "+texp.code +"\n");
   						        RESULT = Tipo.getTipo(Tipo.TIPO_VOID);
   						   }
   						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("assignment_statement",93, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 186: // closed_if_statement ::= IF boolean_expression THEN closed_statement ELSE closed_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("closed_if_statement",92, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 185: // open_if_statement ::= IF boolean_expression THEN closed_statement ELSE open_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("open_if_statement",91, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 184: // open_if_statement ::= IF boolean_expression THEN statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("open_if_statement",91, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 183: // closed_with_statement ::= WITH record_variable_list DO closed_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("closed_with_statement",90, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 182: // open_with_statement ::= WITH record_variable_list DO open_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("open_with_statement",89, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 181: // closed_for_statement ::= for_designator DO closed_statement 
            {
              Object RESULT =null;
		int fdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int fdright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<String> fd = (List<String>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
								parser.code.append("\t LD R3 , "+fd.get(0)+"\n");
							    if(fd.get(1) != null && fd.get(1).toLowerCase().equals("to")) {
									parser.code.append("\t ADD R3 , R3 , #1\n");
								}
								else if(fd.get(1) != null && fd.get(1).toLowerCase().equals("downto")) {
									parser.code.append("\t SUB R3 , R3 , #1\n");
								}
								parser.code.append("\t ST "+fd.get(0)+" , R3\n");
								parser.code.append("\t BR "+fd.get(2)+"\n");
								parser.code.append(fd.get(3)+":\n");
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("closed_for_statement",88, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 180: // open_for_statement ::= for_designator DO open_statement 
            {
              Object RESULT =null;
		int fdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int fdright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<String> fd = (List<String>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
							parser.code.append("\t LD R3 , "+fd.get(0)+"\n");
							if(fd.get(1) != null && fd.get(1).toLowerCase().equals("to")) {
								parser.code.append("\t ADD R3 , R3 , #1\n");
							}
							else if(fd.get(1) != null && fd.get(1).toLowerCase().equals("downto")) {
								parser.code.append("\t SUB R3 , R3 , #1\n");
							}
                          	parser.code.append("\t ST "+fd.get(0)+" , R3\n");
                          	parser.code.append("\t BR "+fd.get(2)+"\n");
                          	parser.code.append(fd.get(3)+":\n");
                          	
                          
              CUP$parser$result = parser.getSymbolFactory().newSymbol("open_for_statement",87, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 179: // for_designator ::= FOR control_variable ASSIGNMENT initial_value direction final_value 
            {
              List<String> RESULT =null;
		int cvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int cvright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Exp cv = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int ivleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ivright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Exp iv = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int dirleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int dirright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		String dir = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int fvleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fvright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp fv = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						String lbl1 = "", lblFalse = "";
						if(!cv.tipo.getVal().equals("error")) {
							if(!cv.tipo.getVal().equals(iv.tipo.getVal())) {
								parser.sem_error(cv.tipo.getVal(), "The type of initial value must be ");
							}
							else if(!cv.tipo.getVal().equals(fv.tipo.getVal())) {
								parser.sem_error(cv.tipo.getVal(), "The type of final value must be ");
							}
							else {
								parser.code.append("\t ST "+cv.code+" , "+iv.code+"\n");
								labels.add(labels.size()+1);
								lbl1 = "$L"+labels.size();
								parser.code.append(lbl1+":\n");
								parser.code.append("\t LD R4 , "+fv.code+"\n");
								parser.code.append("\t LD R3 , "+cv.code+"\n");
								parser.code.append("\t SUB R0 , R3 , R4\n");
								labels.add(labels.size()+1);
								lblFalse = "$L"+labels.size();
								if(dir != null && dir.toLowerCase().equals("to"))
									parser.code.append("\t BGTZ R0 , "+lblFalse+"\n");
								else if(dir != null && dir.toLowerCase().equals("downto"))
									parser.code.append("\t BLTZ R0 , "+lblFalse+"\n");
							}
						}
						List<String> forArgs = new ArrayList<String>();
						forArgs.add(cv.code);
						forArgs.add(dir);
						forArgs.add(lbl1);
						forArgs.add(lblFalse);
						RESULT = forArgs;
					  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("for_designator",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 178: // closed_while_statement ::= while_designator DO closed_statement 
            {
              Object RESULT =null;
		int wdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int wdright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<String> wd = (List<String>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
								 parser.code.append("\t BR "+wd.get(0)+"\n");
								 parser.code.append(wd.get(1)+":\n");
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("closed_while_statement",86, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 177: // open_while_statement ::= while_designator DO open_statement 
            {
              Object RESULT =null;
		int wdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int wdright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<String> wd = (List<String>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		
								 parser.code.append("\t BR "+wd.get(0)+"\n");
								 parser.code.append(wd.get(1)+":\n");
							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("open_while_statement",85, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 176: // while_designator ::= WHILE boolean_expression 
            {
              List<String> RESULT =null;
		int beleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int beright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp be = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							String lbl1 = "", lblFalse = "";
							
							labels.add(labels.size()+1);
							lbl1 = "$L"+labels.size();
							
							parser.code.append(lbl1+":\n");
							parser.code.append("\t LD R0 , "+be.code+"\n");
							parser.code.append("\t SUB R0 , R0 , 1\n");
							
							labels.add(labels.size()+1);
							lblFalse = "$L"+labels.size();
							
							parser.code.append("\t BLTZ R0 , "+lblFalse+"\n");
							
							List<String> whileArgs = new ArrayList <String> ();
							whileArgs.add(lbl1);
							whileArgs.add(lblFalse);
							
							RESULT = whileArgs;
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("while_designator",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 175: // repeat_statement ::= REPEAT NT$8 statement_sequence UNTIL boolean_expression 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int beleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int beright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp be = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
							parser.code.append("\t LD R0"+" , "+be.code+"\n");
							parser.code.append("\t SUB R1 , R0 , 1\n");
							parser.code.append("\t BEQZ R1 , $L"+label+"\n");
							label --;
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("repeat_statement",84, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 174: // NT$8 ::= 
            {
              Object RESULT =null;
   
									labels.add(labels.size()+1);
									label = labels.size();
									parser.code.append("$L"+labels.size()+":\n");
						       
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$8",142, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 173: // non_labeled_open_statement ::= open_for_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_open_statement",83, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 172: // non_labeled_open_statement ::= open_while_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_open_statement",83, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 171: // non_labeled_open_statement ::= open_if_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_open_statement",83, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 170: // non_labeled_open_statement ::= open_with_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_open_statement",83, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 169: // non_labeled_closed_statement ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",82, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 168: // non_labeled_closed_statement ::= closed_for_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",82, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 167: // non_labeled_closed_statement ::= closed_while_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",82, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 166: // non_labeled_closed_statement ::= closed_if_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",82, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 165: // non_labeled_closed_statement ::= closed_with_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",82, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 164: // non_labeled_closed_statement ::= repeat_statement 
            {
              Object RESULT =null;
		 	
											labels.add(labels.size()+1);
											parser.code.append("$L"+labels.size()+":\n");
										
              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",82, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 163: // non_labeled_closed_statement ::= case_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",82, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 162: // non_labeled_closed_statement ::= compound_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",82, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 161: // non_labeled_closed_statement ::= goto_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",82, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 160: // non_labeled_closed_statement ::= procedure_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",82, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 159: // non_labeled_closed_statement ::= assignment_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_labeled_closed_statement",82, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 158: // closed_statement ::= non_labeled_closed_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("closed_statement",81, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 157: // closed_statement ::= label COLON non_labeled_closed_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("closed_statement",81, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 156: // open_statement ::= non_labeled_open_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("open_statement",80, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 155: // open_statement ::= label COLON non_labeled_open_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("open_statement",80, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 154: // statement ::= closed_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",79, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 153: // statement ::= open_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement",79, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 152: // statement_sequence ::= statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement_sequence",78, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 151: // statement_sequence ::= statement_sequence semicolon statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement_sequence",78, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 150: // compound_statement ::= BEGIN statement_sequence END 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("compound_statement",77, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 149: // statement_part ::= compound_statement 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("statement_part",76, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 148: // function_block ::= block 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_block",75, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 147: // function_identification ::= FUNCTION identifier 
            {
              String RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
					if(! TabelaDeSimbolos.inserir(id.toLowerCase(), new Simbolo(id, new TipoFuncao(Tipo.getTipo(Tipo.TIPO_VOID))))) {
                            parser.sem_error(id, "duplicate name");
                            RESULT = null;
                    }
                    else {
						RESULT = id;
					} 
				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_identification",70, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 146: // result_type ::= type_denoter 
            {
              Tipo RESULT =null;
		int tdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo td = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = td; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("result_type",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 145: // function_heading ::= function_identification NT$7 formal_parameter_list COLON result_type 
            {
              Object RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int fileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int firight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String fi = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int fplleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int fplright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<Tipo> fpl = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rtleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rtright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo rt = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   							
   							if(fi != null) {
								Simbolo s = TabelaDeSimbolos.get(fi.toLowerCase());
								TipoFuncao t = (TipoFuncao) s.getTipo();
								t.setTipoRetorno(rt);
								t.addParamTipo(fpl);
							}
                             
                        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_heading",74, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 144: // NT$7 ::= 
            {
              Object RESULT =null;
		int fileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int firight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String fi = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
TabelaDeSimbolos.push(); parser.code.append(fi+": \n");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$7",141, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 143: // function_heading ::= FUNCTION identifier COLON result_type 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int rtleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int rtright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo rt = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   							if(! TabelaDeSimbolos.inserir(id.toLowerCase(), new Simbolo(id, new TipoFuncao(rt)))) {
                            	parser.sem_error(id, "duplicate name");
                            } else {
								TabelaDeSimbolos.push();
								parser.code.append(id+": \n");
                            } 
   						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_heading",74, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 142: // function_declaration ::= function_heading semicolon function_block 
            {
              Object RESULT =null;
		
                              parser.code.append("\t BR *0(SP) \n"); 
                              TabelaDeSimbolos.pop();
                            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_declaration",73, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 141: // function_declaration ::= function_identification semicolon function_block 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_declaration",73, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 140: // function_declaration ::= function_heading semicolon directive 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("function_declaration",73, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 139: // procedure_block ::= block 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_block",72, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 138: // procedure_identification ::= PROCEDURE identifier 
            {
              String RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
									
   									if(! TabelaDeSimbolos.inserir(id.toLowerCase(), new Simbolo(id, new TipoFuncao(Tipo.getTipo(Tipo.TIPO_VOID))))) {
                            			parser.sem_error(id, "duplicate name");
                            			RESULT = "";
                            		}
                            		else {
                            			RESULT = id;
                            		}
                        		
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_identification",69, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 137: // functional_parameter_specification ::= function_heading 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("functional_parameter_specification",68, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 136: // procedural_parameter_specification ::= procedure_heading 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedural_parameter_specification",67, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 135: // variable_parameter_specification ::= VAR identifier_list COLON type_denoter 
            {
              List<Tipo> RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<String> il = (List<String>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo td = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
								/* para facilitar, consideramos que as duas formas recebem parmetros */
										 
   									    List<Tipo> l = new ArrayList<Tipo>();
   									    int i = 0;
   										for(String id : il) {
                            				if(! TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, td))) {
                            					parser.sem_error(id, "duplicate name");
                            				}
                            				l.add(td);
                            				argRegs.add(new Reg("A"+i, id));
											i++;
                            			}
                            			RESULT = l;
   								
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_parameter_specification",66, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 134: // value_parameter_specification ::= identifier_list COLON type_denoter 
            {
              List<Tipo> RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<String> il = (List<String>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo td = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   								    List<Tipo> l = new ArrayList<Tipo>();
   									for(String id : il) {
                            			if(! TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, td))) {
                            				parser.sem_error(id, "duplicate name");
                            			}
                            			l.add(td);
                            			argRegs.add(new Reg("A"+argRegs.size(), id));
                            		}
                            		RESULT = l;
   								
              CUP$parser$result = parser.getSymbolFactory().newSymbol("value_parameter_specification",65, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 133: // formal_parameter_section ::= functional_parameter_specification 
            {
              List<Tipo> RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section",64, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 132: // formal_parameter_section ::= procedural_parameter_specification 
            {
              List<Tipo> RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section",64, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 131: // formal_parameter_section ::= variable_parameter_specification 
            {
              List<Tipo> RESULT =null;
		int varpsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int varpsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<Tipo> varps = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = varps; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section",64, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 130: // formal_parameter_section ::= value_parameter_specification 
            {
              List<Tipo> RESULT =null;
		int vpsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int vpsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<Tipo> vps = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = vps; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section",64, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 129: // formal_parameter_section_list ::= formal_parameter_section 
            {
              List<Tipo> RESULT =null;
		int fpsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fpsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<Tipo> fps = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                                   List<Tipo> l = new ArrayList<Tipo>();
                                   for(Tipo t : fps) {
                                   		l.add(t);
                                   } 
                                   RESULT = l;
                                   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section_list",63, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 128: // formal_parameter_section_list ::= formal_parameter_section_list semicolon formal_parameter_section 
            {
              List<Tipo> RESULT =null;
		int fpslleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int fpslright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<Tipo> fpsl = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int fpsleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fpsright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<Tipo> fps = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
										for(Tipo t : fps) {
											fpsl.add(t);
										} 
										RESULT = fpsl;
                                   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_section_list",63, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 127: // formal_parameter_list ::= LPAREN formal_parameter_section_list RPAREN 
            {
              List<Tipo> RESULT =null;
		int fpslleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int fpslright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		List<Tipo> fpsl = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = fpsl; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("formal_parameter_list",62, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 126: // directive ::= EXTERNAL 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("directive",61, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 125: // directive ::= FORWARD 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("directive",61, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 124: // procedure_heading ::= procedure_identification NT$6 formal_parameter_list 
            {
              Object RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int pileft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int piright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String pi = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int fplleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int fplright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		List<Tipo> fpl = (List<Tipo>)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 Simbolo s = TabelaDeSimbolos.get(pi.toLowerCase());
                            if(s != null) {
								TipoFuncao t = (TipoFuncao) s.getTipo();
								t.addParamTipo(fpl);
							}
                         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_heading",60, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 123: // NT$6 ::= 
            {
              Object RESULT =null;
		int pileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int piright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String pi = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
 TabelaDeSimbolos.push(); parser.code.append(pi+": \n"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$6",140, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 122: // procedure_heading ::= procedure_identification 
            {
              Object RESULT =null;
		int pileft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int piright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String pi = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		TabelaDeSimbolos.push(); parser.code.append(pi+": \n");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_heading",60, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 121: // procedure_declaration ::= procedure_heading semicolon procedure_block 
            {
              Object RESULT =null;
		
								parser.code.append("\t BR *0(SP) \n");
								TabelaDeSimbolos.pop();
                             
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_declaration",59, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 120: // procedure_declaration ::= procedure_heading semicolon directive 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_declaration",59, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 119: // proc_or_func_declaration ::= function_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("proc_or_func_declaration",58, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 118: // proc_or_func_declaration ::= procedure_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("proc_or_func_declaration",58, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 117: // proc_or_func_declaration_list ::= proc_or_func_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("proc_or_func_declaration_list",57, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 116: // proc_or_func_declaration_list ::= proc_or_func_declaration_list semicolon proc_or_func_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("proc_or_func_declaration_list",57, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 115: // procedure_and_function_declaration_part ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_and_function_declaration_part",56, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // procedure_and_function_declaration_part ::= proc_or_func_declaration_list semicolon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("procedure_and_function_declaration_part",56, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // variable_declaration ::= error NT$5 semicolon 
            {
              Object RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_declaration",55, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // NT$5 ::= 
            {
              Object RESULT =null;
 parser.report_error("","expected ';' before token"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$5",139, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // variable_declaration ::= identifier_list COLON type_denoter semicolon 
            {
              Object RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		List<String> il = (List<String>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int tdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Tipo td = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                            	for(String id : il) {
                            		if(! TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, td))) {
                            			parser.sem_error(id, "duplicate name");
                            		}
                            	}
   							
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_declaration",55, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // variable_declaration_list ::= variable_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_declaration_list",54, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // variable_declaration_list ::= variable_declaration_list variable_declaration 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_declaration_list",54, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // variable_declaration_part ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_declaration_part",53, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // variable_declaration_part ::= VAR variable_declaration_list 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variable_declaration_part",53, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // domain_type ::= identifier 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("domain_type",52, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // new_pointer_type ::= UPARROW domain_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_pointer_type",51, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // file_type ::= PFILE OF component_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("file_type",50, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // base_type ::= ordinal_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("base_type",49, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // set_type ::= SET OF base_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("set_type",48, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // tag_type ::= identifier 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tag_type",47, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // tag_field ::= identifier 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tag_field",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // case_constant ::= constant DOTDOT constant 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("case_constant",45, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // case_constant ::= constant 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("case_constant",45, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // case_constant_list ::= case_constant 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("case_constant_list",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // case_constant_list ::= case_constant_list comma case_constant 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("case_constant_list",44, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // variant ::= case_constant_list COLON LPAREN variant_part RPAREN 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant",43, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // variant ::= case_constant_list COLON LPAREN record_section_list semicolon variant_part RPAREN 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant",43, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // variant ::= case_constant_list COLON LPAREN record_section_list RPAREN 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant",43, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // variant_list ::= variant 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_list",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // variant_list ::= variant_list semicolon variant 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_list",42, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // variant_selector ::= tag_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_selector",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // variant_selector ::= tag_field COLON tag_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_selector",41, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // variant_part ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_part",40, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // variant_part ::= CASE variant_selector OF variant_list 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_part",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // variant_part ::= CASE variant_selector OF variant_list semicolon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("variant_part",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // record_section ::= identifier_list COLON type_denoter 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_section",39, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // record_section_list ::= record_section 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_section_list",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // record_section_list ::= record_section_list semicolon record_section 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_section_list",38, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // record_type ::= RECORD variant_part END 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_type",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // record_type ::= RECORD record_section_list semicolon variant_part END 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_type",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // record_type ::= RECORD record_section_list END 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("record_type",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // component_type ::= type_denoter 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("component_type",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // ordinal_type ::= identifier 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ordinal_type",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // ordinal_type ::= new_ordinal_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ordinal_type",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // index_type ::= ordinal_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("index_type",34, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // index_list ::= index_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("index_list",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // index_list ::= index_list comma index_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("index_list",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // array_type ::= ARRAY LBRAC index_list RBRAC OF component_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("array_type",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // structured_type ::= file_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("structured_type",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // structured_type ::= set_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("structured_type",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // structured_type ::= record_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("structured_type",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // structured_type ::= array_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("structured_type",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // new_structured_type ::= PACKED structured_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_structured_type",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // new_structured_type ::= structured_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_structured_type",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // subrange_type ::= constant DOTDOT constant 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("subrange_type",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // enumerated_type ::= LPAREN identifier_list RPAREN 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("enumerated_type",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // new_ordinal_type ::= subrange_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_ordinal_type",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // new_ordinal_type ::= enumerated_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_ordinal_type",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // new_type ::= new_pointer_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_type",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // new_type ::= new_structured_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_type",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // new_type ::= new_ordinal_type 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("new_type",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // type_denoter ::= BOOLEAN 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.BOOLEAN); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_denoter",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // type_denoter ::= REAL 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.REAL); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_denoter",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // type_denoter ::= CHAR 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.CHAR); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_denoter",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // type_denoter ::= INTEGER 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.INTEGER); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_denoter",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // type_denoter ::= STRING 
            {
              Tipo RESULT =null;
		 RESULT = Tipo.getTipo(Tipo.STRING); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_denoter",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // type_denoter ::= new_type 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_denoter",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // type_denoter ::= IDENTIFIER 
            {
              Tipo RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
   						Simbolo t = null;
   						if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   							parser.sem_error(id, "undefined type");
   							RESULT = Tipo.getTipo(Tipo.ERRO);
   						} else {
   							RESULT = t.getTipo(); 
   						}
   					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_denoter",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // type_definition ::= error NT$4 semicolon 
            {
              Object RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_definition",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // NT$4 ::= 
            {
              Object RESULT =null;
 parser.report_error("","expected ';' before token"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$4",138, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // type_definition ::= identifier EQUAL type_denoter semicolon 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int tdleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tdright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Tipo td = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 if(! TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, td, true))) {
                            	parser.sem_error(id, "duplicate name");
                       } 
                     
              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_definition",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // type_definition_list ::= type_definition 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_definition_list",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // type_definition_list ::= type_definition_list type_definition 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_definition_list",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // type_definition_part ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_definition_part",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // type_definition_part ::= TYPE type_definition_list 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("type_definition_part",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // non_string ::= REALNUMBER 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_string",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // non_string ::= identifier 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_string",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // non_string ::= DIGSEQ 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("non_string",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // sign ::= MINUS 
            {
              String RESULT =null;
		int mnleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int mnright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String mn = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = mn; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sign",131, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // sign ::= PLUS 
            {
              String RESULT =null;
		int plleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int plright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String pl = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = pl; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sign",131, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // constant ::= CHARACTER_STRING 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // constant ::= sign non_string 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // constant ::= non_string 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // cprimary ::= NOT cprimary 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cprimary",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // cprimary ::= unsigned_constant 
            {
              Tipo RESULT =null;
		int ucleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ucright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Exp uc = (Exp)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT  = uc.tipo; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cprimary",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // cprimary ::= LPAREN cexpression RPAREN 
            {
              Tipo RESULT =null;
		int celeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int ceright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Tipo ce = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 RESULT = ce; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cprimary",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // cprimary ::= identifier 
            {
              Tipo RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
   				    Simbolo t = null;
   					if((t = TabelaDeSimbolos.get(id.toLowerCase())) == null) {
   						parser.sem_error(id, "unknow name");
   						RESULT = Tipo.getTipo(Tipo.ERRO);
   					} else {
   						RESULT = t.getTipo(); 
   					}
   				
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cprimary",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // cexponentiation ::= cprimary STARSTAR cexponentiation 
            {
              Tipo RESULT =null;
		int cpleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cpright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Tipo cp = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		 RESULT = cp; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cexponentiation",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // cexponentiation ::= cprimary 
            {
              Tipo RESULT =null;
		int cpleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cpright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo cp = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = cp; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cexponentiation",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // cfactor ::= cexponentiation 
            {
              Tipo RESULT =null;
		int celeft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ceright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo ce = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = ce; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cfactor",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // cfactor ::= sign cfactor 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cfactor",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // cterm ::= cterm mulop cfactor 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cterm",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // cterm ::= cfactor 
            {
              Tipo RESULT =null;
		int cfleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cfright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo cf = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = cf; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cterm",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // csimple_expression ::= csimple_expression addop cterm 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("csimple_expression",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // csimple_expression ::= cterm 
            {
              Tipo RESULT =null;
		int ctleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int ctright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo ct = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = ct; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("csimple_expression",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // cexpression ::= csimple_expression relop csimple_expression 
            {
              Tipo RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cexpression",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // cexpression ::= csimple_expression 
            {
              Tipo RESULT =null;
		int cseleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cseright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Tipo cse = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = cse; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cexpression",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // constant_definition ::= error NT$3 semicolon 
            {
              Object RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant_definition",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // NT$3 ::= 
            {
              Object RESULT =null;
 parser.report_error("","expected ';' before token"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",137, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // constant_definition ::= identifier EQUAL cexpression semicolon 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int tceleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tceright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Tipo tce = (Tipo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		 if(! TabelaDeSimbolos.inserirVariavel(id.toLowerCase(), new Simbolo(id, tce, true))) {
                            	parser.sem_error(id, "duplicate name");
                            }  
                         
              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant_definition",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // constant_list ::= constant_definition 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant_list",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // constant_list ::= constant_list constant_definition 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant_list",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // constant_definition_part ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant_definition_part",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // constant_definition_part ::= CONST constant_list 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("constant_definition_part",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // label ::= DIGSEQ 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // label_list ::= label 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label_list",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // label_list ::= label_list comma label 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label_list",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // label_declaration_part ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label_declaration_part",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // label_declaration_part ::= error NT$2 semicolon 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label_declaration_part",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // NT$2 ::= 
            {
              Object RESULT =null;
 parser.report_error("","expected ';' before token"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",136, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // label_declaration_part ::= LABEL label_list semicolon 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("label_declaration_part",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // module ::= constant_definition_part type_definition_part variable_declaration_part procedure_and_function_declaration_part 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("module",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // block ::= label_declaration_part constant_definition_part type_definition_part variable_declaration_part procedure_and_function_declaration_part NT$1 statement_part 
            {
              Object RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("block",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // NT$1 ::= 
            {
              Object RESULT =null;
 
				 if(TabelaDeSimbolos.escopoCorrente.isRoot()) { 
					parser.code.append("main: \n");
				 } 
			   
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",135, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // identifier_list ::= IDENTIFIER 
            {
              List<String> RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		   List<String> il = new ArrayList<String>();
   					 						il.add(id.toLowerCase());
   					 						RESULT = il; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("identifier_list",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // identifier_list ::= identifier_list comma IDENTIFIER 
            {
              List<String> RESULT =null;
		int illeft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int ilright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		List<String> il = (List<String>)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 il.add(id.toLowerCase()); RESULT = il; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("identifier_list",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // program_heading ::= PROGRAM identifier NT$0 LPAREN identifier_list RPAREN 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("program_heading",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$0 ::= 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
 
							parser.code.append("// Assembly code to "+id+" \n\n"); 
							parser.code.append("\t LD SP , #stackStart\n"); 
							parser.code.append("\t BR main \n"); 
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",134, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program_heading ::= PROGRAM identifier 
            {
              Object RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String id = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
							parser.code.append("; Codigo assembly simples para "+id+".\n"); 
							parser.code.append("; Os registradores A0...An sao argumentos de funcoes/procedimentos.\n");
							parser.code.append("; O registrador V0 guarda retorno de funcoes.\n\n"); 
							parser.code.append("\t LD SP , #stackStart\n"); 
							parser.code.append("\t BR main \n"); 
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program_heading",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // program ::= program_heading semicolon block DOT 
            {
              Object RESULT =null;
		 parser.code.append("\t HALT \n\n"); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

